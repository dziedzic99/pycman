PycMan
Jan Dziedzic
November 28, 2017

Contents
1 Project Definition and Analysis
1.1 Project Definition . . . . . . . . . . . . . . .
1.2 Stakeholders . . . . . . . . . . . . . . . . . .
1.3 Software Challenges . . . . . . . . . . . . .
1.4 The Interview . . . . . . . . . . . . . . . . .
1.5 Requirement specification (success criteria)
2 Design
2.1 Main window layout . . . . . . . . . . . .
2.1.1 Board . . . . . . . . . . . . . . . .
2.1.2 Counters . . . . . . . . . . . . . .
2.2 Grid layout . . . . . . . . . . . . . . . . .
2.3 Types of tiles . . . . . . . . . . . . . . . .
2.3.1 Walls . . . . . . . . . . . . . . . .
2.3.2 Player . . . . . . . . . . . . . . . .
2.3.3 Ghosts . . . . . . . . . . . . . . . .
2.3.4 Eatables . . . . . . . . . . . . . . .
2.3.5 Empty tiles . . . . . . . . . . . . .
2.4 Levels . . . . . . . . . . . . . . . . . . . .
2.4.1 Permanent storing . . . . . . . . .
2.4.2 Storing while in game . . . . . . .
2.4.3 Interpreting . . . . . . . . . . . . .
2.4.4 Designing the levels . . . . . . . .
2.4.5 User-defined levels . . . . . . . . .
2.4.6 Progressing to the next level . . .
2.5 Gameplay scheme . . . . . . . . . . . . . .
2.5.1 Introduction to the concept of time
2.5.2 Player movement . . . . . . . . . .
2.5.3 Ghost movement . . . . . . . . . .
2.5.4 Handling movement animation . .
2.5.5 Eating . . . . . . . . . . . . . . . .
2.5.6 Getting killed . . . . . . . . . . . .
2.5.7 Respawning after a loss of life . . .

2

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

5
6
7
7
9
10

. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
segments
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

13
14
15
16
17
19
19
23
23
24
25
25
25
26
28
29
29
29
30
30
30
32
38
40
41
41

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

2.6

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

41
43
43
43
43
44
44
44
44
45

3 Implementation
3.1 Programming tools . . . . . . . . . . . . . . .
3.1.1 PyCharm . . . . . . . . . . . . . . . .
3.1.2 GIMP . . . . . . . . . . . . . . . . . .
3.1.3 Git . . . . . . . . . . . . . . . . . . . .
3.1.4 TeXstudio . . . . . . . . . . . . . . . .
3.1.5 Other tools . . . . . . . . . . . . . . .
3.2 Interpreter and its modules . . . . . . . . . .
3.2.1 Virtual Environment . . . . . . . . . .
3.2.2 Modules . . . . . . . . . . . . . . . . .
3.3 Project structure . . . . . . . . . . . . . . . .
3.4 Classes . . . . . . . . . . . . . . . . . . . . . .
3.4.1 GameObject . . . . . . . . . . . . . .
3.4.2 Eatable . . . . . . . . . . . . . . . . .
3.4.3 Wall . . . . . . . . . . . . . . . . . . .
3.4.4 Movable . . . . . . . . . . . . . . . . .
3.4.5 Player . . . . . . . . . . . . . . . . . .
3.4.6 Ghost . . . . . . . . . . . . . . . . . .
3.5 Resources . . . . . . . . . . . . . . . . . . . .
3.5.1 Constants . . . . . . . . . . . . . . . .
3.6 Level processing . . . . . . . . . . . . . . . .
3.6.1 Reading bitmap files . . . . . . . . . .
3.6.2 Checking wall type . . . . . . . . . . .
3.6.3 Adding Sprites according to tile types
3.6.4 Sprite Groups . . . . . . . . . . . . . .
3.7 Ghost pathfinding algorithm . . . . . . . . . .
3.7.1 Graph structure . . . . . . . . . . . .
3.7.2 Graph building . . . . . . . . . . . . .
3.7.3 Choosing a target tile for each ghost .
3.7.4 Actual pathfinding . . . . . . . . . . .
3.8 Designing resources . . . . . . . . . . . . . . .
3.9 Core program code . . . . . . . . . . . . . . .
3.9.1 Playing a single level . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

46
46
46
47
47
47
48
48
48
48
49
50
51
51
52
52
53
54
55
55
57
57
58
59
60
60
60
60
61
62
65
65
65

2.7

Types of message screens . . . . .
2.6.1 Tutorial . . . . . . . . . . .
2.6.2 Loss of life . . . . . . . . .
2.6.3 Completing a level . . . . .
2.6.4 Loosing the game . . . . . .
2.6.5 Completing the entire game
Testing . . . . . . . . . . . . . . .
2.7.1 zero-testing . . . . . . . . .
2.7.2 α-testing . . . . . . . . . .
2.7.3 β-testing . . . . . . . . . .

3

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

3.9.2
3.9.3

Function switching levels . . . . . . . . . . . . . . . .
Displaying messages . . . . . . . . . . . . . . . . . . .

4 Code appendix
4.1 main.py . . . . .
4.2 classes.py . . . .
4.3 levelprocessor.py
4.4 paths.py . . . . .

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

68
69
70
70
77
80
80

5 Levels appendix

82

6 References

83

4

Chapter 1

Project Definition and
Analysis

5

1.1

Project Definition

Figure 1.1: Original Pac-Man screen. Source is Reference 1.
As my project, I have decided to present a game written in Python,
based around one of its modules - pygame. As I have not had as much time
to prepare my project as my colleagues, I have decided that the concept of
the game must be simple, yet allowing to demonstrate my programming and
computational thinking skills. For this purpose I have decided to mimic the
iconic PacMan game. For picture of the original game screen please refer to
Figure 1.1
Called PycMan (utilizing the fact that many of Python modules have a
prefix ’py’ in their name), the game itself strongly resembles the original,
yet with some meaningful changes. Like in the original - player can move
in four directions (left, right, up and down), collecting coins and avoiding
ghosts.
The game develops critical thinking skills and takes effect of human
nature of taking risks and tackling unknown - with having more confidence
when predicting ghost behavior, the player actually gets better when playing
despite problems generally low complexity.
Actually the game itself may be referred as to playing tag in a transparent
6

maze. Such a play would be very hard for a human to enjoy as analyzing
transparent walls while running and predicting opponent’s next move is a
far too complex problem for human cognition. That’s why computational
approach on this game is required - where player can see ghosts from above
the board whilst ghost may exhibit algorithmically advanced behavior.

1.2

Stakeholders

Proposed end user group is really wide. As the game itself can be launched
on virtually any device due to Python versatility, it may be used on a spectrum of devices with different controllers, from mobile phones and smart
watches through PCs reaching as far as game console emulators mimicking the most authentic PacMan game experience. Such portability should
satisfy most users.
The game should grab attention of children - with small challenges that
don’t require complex thinking and rather promote manual skills and reflex; those who seek quick brainteaser whilst attempting to play with more
focus on tactics of ghost avoidance and finally, old gamers who played original PacMan but now they might want to try more modern version with a
different approach to critical game mechanisms.
A good example of a stakeholder is my friend, Wojciech Wojtkowski,
with whom I have conducted an interview to determine the requirements,
see Section 1.4 for reference.

1.3

Software Challenges

All software used to develop the game but is not necessarily required to run
it:
• Python3
Pillow module
Pygame module
• Pycharm Professional
• GIMP - GNU Image Manipulation Program
• LATEX
• TeXstudio
• LibreOffice Draw
The greatest advantage that convinced me to actually use Python for my
game was its portability. As an interpretable programming language, the
code of the game remains universal throughout different operating systems
7

and processor architectures. My decision was also influenced by my previous
experience with this language and my desire to actually get better around it.
It’s also free, meaning that everyone can take benefit of my game, without
having to buy a license from a third party.
Also, whilst most of my experience was with Python2 I have decided
that it’s the right time to move on and actually start using Python3, which
is reportedly faster and offers more functionality while providing greater
stability.
Still, Python does not offer the speed one may expect from a programming language suitable for complex games. Advanced non-optimal solutions
need to be thought of and substituted with faster algorithms in order for
the game to run smooth on machines lacking processing power.
Happily Python is an objective language - which greatly helped with
some designs.
As it’s also an interpretable language, it’s way easier to debug as one
may actually run every single line of code step by step to see variable values
changing. Python interpreters also provide a very generous error descriptions greatly helping with bug fixing.
The closest I could get with Python to making a full featured game conveniently was to use pygame. It’s a rather good module supplying some
basic functionality one may expect from assisted-design library for creating
2D games. Some functions were not supported out of the box, like level storing (suitable for my purpose) and loading and these had to be implemented
by myself as an addition.
Pygame also doesn’t have a tiling system I wanted for level designs,
to make my game resemble original PacMan in terms of design. I had to
write such myself. A similar situation occurred when I wanted to implement
discrete ”Time Segments” (see Section 2.5.1 for reference). For a game such
as PacMan I find such solutions to be a very useful optimization and yet
these are missing from the pygame module.
Pycharm by JetBrains was used as a Python IDE - it is a really convinient
solution and comes with a lot of useful features. It was chosen due to my
previous positive experience with it.
GIMP was used to produce graphics resources of the game as well as
levels - described later. I found it to be a great deal of overkill for such basic
tasks but I am very familiar with it’s interface and tools which were of great
help especially during the design of semi-transparent ghost graphics.
Libre Office Draw is a free office suite component meant to be used for
developing multimedia presentations. I have used it for its great tool for
developing flowcharts used in this document. See Figure 2.27 for example
of such graphics.
LATEXand Texstudio were used to develop this document. As I identify
as a pro-open-source-software person I wanted to use LATEXinstead of word
processors with a far advanced UI, like Microsoft Word. A practical reason
8

behind this - LATEXprovides an absolutely full flexibility. And even when it
doesn’t have a function I might want to use - I can always write such myself.
All development was done on an Ubuntu-running computer, therefore
I must proudly admit that during the entire design process no non-free
software was used. All software was either opensource, freeware or free for
education.

1.4

The Interview

To assess interest and gain insight of the potential market for the game, I
have interviewed my fellow schoolmate - Wojciech Wojtkowski on his opinion
of my approach to redesigning PacMan.
-Hello Wojciech, may I interest you with my Computer Science project
- the PycMan, next generation of the classic PacMan with smarter ghosts
and different mechanics?
-Sure mate, go ahead!
-Ok, so these are some concept graphics [first two levels were exhibited]...
-...but it looks just like the original!
-Yes, there is a strong resemblance in terms of the graphics, that’s what
I am aiming for. The biggest difference is how the ghost work.
-Oh, tell me more.
-So, in the classical PacMan, the ghost have their designated area they
launch from, A.K.A. ”The Ghost House”, I want to get rid of that, instead
all ghosts will start from predefined locations different for each level.
-That means they will chase you from the exact beginning of the level,
isn’t that going to make the game harder?
-Yes it will, that is the goal. But that’s not the main change. They will
be smarter than the originals.
-You mean that the way they move is going to be less predictable?
-That’s true, I want to utilize a rather complex algorithm to make them
chase player more efficiently.
-Didn’t the original have the most efficient solution?
-No, the target machines lacked processing power and memory in the
past to actually use that with the game not slowing down. Now, when
newer computers are available, I can actually use that.
-So if they were quite stupid then and the game was still hard, won’t
making them smart render the game impossible to win?
-That’s what I am afraid of, I need to find a way to give the player some
advantage. Do you, as an experienced gamer, have any idea how to do that?
-I think that making the ghost chase the player indirectly may be the
way, how about them tailing the PycMan?
-Yeah, that migh be fine but this may eventually lead to them not catching it at all if it doesn’t move.

9

-Oh, that might be the case.
-Actually I have one solution in mind - making them a little bit slower
than the player.
-Seems okay, thought I think that one may run away from them, do a
risky eating-maneuver then and regain the distance lost. Repeating that
will make the game easy and very boring actually.
-Oh, true, I will have to think of these solutions. Probably final version
will be designed during beta testing based on player satisfaction with each
of these methods.
-Good idea to let the players decide. Actually - on the player-decision
thing. One thing that I always wanted with PacMan is to design my own
levels. Can you make it possible?
-Yeah, I already have a solution in mind that will make it very easy for
anyone to design their own maze, if you say that’s going to interest players,
I will surely include that.
-Cool! Thanks for letting me know, can I play that game later?
-Of course, as soon as I release the beta.
-Perfect, thank you then, I look forward to playing it.
-Thank you for the talk and insight. Bye.
-Bye.

1.5

Requirement specification (success criteria)

For the project to succeed the following criteria must be met:
1. The game must resemble the original PacMan in terms of graphical
design and some of the mechanics.
(a) Game graphics should be of similar color and shape to the originals.
(b) Player sprite is an iconic yellow ball with ’mouth’.
(c) Player sprite should rotate with ’mouth’ towards the direction of
movement.
(d) Neither ghosts nor player are to pass through wall or be able to
exit board borders.
(e) Ghosts chase the player who loses a life upon contact with a ghost.
(f) Upon losing a life ghosts and the player return to their initial
locations.
(g) Each ghost behaves in a different way based on its color.
(h) Ghosts do not reverse their direction of movement.
10

(i) Player progresses through a level with eating ’coins’ left throughout some/all accessible places on the map.
(j) Upon eating a coin, it disappears and is not to be rendered again.
(k) Eating a coin increases point counter.
(l) Heart shaped Eatables are left in some places in some of the
levels.
(m) Eating a heart grants the player extra one life.
(n) Upon completing the level (eating all ’coins’) new level is loaded.
(o) When player has less than one life the game finishes and the
player loses.
(p) When player completes all the levels, the game finishes and the
player wins.
(q) Text messages appear whenever a significant change in gameplay
is to take place. E.g. Start of the game, level change, player’s
death, completing entire game.
(r) The game must be possible to win.
2. The game must be different from the original in these ways:
(a) Majority of players must find the PycMan ghosts ’smarter’ than
the originals.
(b) There is no ’ghost house’ where ghosts start from. All sprites
move from the beginning and ghost chase the player immediately.
(c) There are no power-ups in the levels.
(d) Ghosts cannot die.
(e) Ghost don’t change ’modes’ and don’t became frightened of the
player.
(f) Player can move faster than the ghosts.
3. Requirements independent from similarities to the original Pac-Man
(a) Arrow keys used to control player’s movement.
(b) Spacebar used to dismiss on-screen messages.
(c) Player sprite must not move without user input.
4. Game must work smoothly (30 frames per second is considered to
be the standard of human perception of fluency) on contemporary
medium-class laptop PCs. The following hardware and software requirements are to be met:
11

(a) Operating system supporting Python3 interpreter
(b) Python3 interpreter
(c) Pillow module (PIL)
(d) Pygame module
(e) Color display of resolution of at least 600x600px
(f) Keyboard
(g) 500 MB of storage space
(h) 512 MB of RAM
(i) 700MHz processor
The game has been tested on described specification machine and has
been found to meet fluency criteria. No testing on slower machines
has been performed as these are not usually available on the market
anymore. Each of the requirements listed is critical to either launch
or play the game.

12

Chapter 2

Design

13

As the game uses Pygame module it obviously derives some solutions
natively implemented in it. All display solutions are actually handled using
the module. Use of Tkinker was researched for pop-up messages but adding
another module that doesn’t bring any outstanding functionality above capabilities of Pygame has been ruled as an unnecessary waste of memory.
Having the fact that my main tool will be the pygame module I have
divided game design process into following subproblems.
• Preparing window environment for the game
• Preparing board and tiling system
• Creating player and ghost sprites
• Handling player input
• Adding Eatables and walls
• Preparing level storage-loading system
• Wall collision handling
• Eating routines
• Ghost movement system
• Advancing through levels
• Pop-up messaging

2.1

Main window layout

Main game window consists of a board where the actual game takes place.
Below the board there is a set of informative counters kept in characteristic PacMan colours of gold-yellow on dark/royal-blue background as per
requirement 1a.

14

Figure 2.1: Game window rendered in Ubuntu Gnome graphical environment.

2.1.1

Board

As each level has a different layout so look of the board may vary. Please
refer to Figure 2.2 for an example of such board.

15

Figure 2.2: Example board. Walls, empty tiles, the player, coins and a red
ghost are visible
General idea is that all border tiles of each level (tile system explained
later) have to be walls, which creates a nice, outer border of the board with
rounded edges.

2.1.2

Counters

Directly below the board, counters are located, these provide information
on:
1. Number of coins eaten
2. Number of coins that are required to be consumed before progressing
to the next level
3. Number of player lives
16

4. Current level number

Figure 2.3: Example set of counters with part of the board included for
position reference.
Every time the player eats a ’coin’ the first counter increases. Throughout
the level, this counter cannot decrease as even upon player’s death, the
already-eaten coins don’t respawn.
Number of coins required to progress is constant through the level but
may differ between levels. It is worth mentioning that as every coin must be
eaten to progress, this acts as a total number of coins allocated in each level
map. Coin placing algorithm described later in this document also proves
that it equals to 322 − #wall tiles − #empty tiles .
Each time a player comes in contact with a ghost(defined later in this
document) a life is subtracted and every time the player eats a heart eatable,
a life is added.
Level number increases from 1 (easiest level) up to ten (hardest level),
as player advances through the levels.

2.2

Grid layout

Pygame provides a sprite attribute of its location but as I have decided to
use a window of over 500x500px of size, its pixel-accurate positioning would
be an overkill and could make programming harder as well as require more
processing power to (later mentioned) pathfinding algorithms. Due to this
I have turned to the original PacMan solution (as read in Reference 1), the
grid system.

17

Figure 2.4: Original Pac-Man with grid layout depicted. Source: Reference
1
The PycMan board was initially made as a 64x64 grid, where each piece,
namely a tile, was either a wall or a space a sprite may move on. First levels
were designed this way and I found the level design a really hard task. Only
1 th
later I have noticed that the grid of the original PacMan was barely
of
4
the size I have used, my board was just to big for a pleasant gameplay.
As I wanted the board to be square I have decided to move to 32x32
18

grid. Some testing later I have decided that this size not only nicely divides
by 2 making perfectly symmetrical or even fractal levels possible to make
but also is actually quite the one most similar in terms of number of tiles to
the one the original PacMan had (for square boards).

Figure 2.5: Example of a board with a grid applied (note that the grid was
added just for demonstrative purposes and in not a part of the game.)
The following section describes types of different tiles used throughout the
game.

2.3
2.3.1

Types of tiles
Walls

As wall tiles have to connect with neighboring (common edge) tiles, they
need to be represented by different graphics depending on their surround19

ings. There is a total of 15 graphics depicted below. The system of numbering them is really intuitive, it consists of four digits each of which is either
zero or one

Figure 2.6: Wall 0001

Figure 2.7: Wall 0010

Figure 2.8: Wall 0011

Figure 2.9: Wall 0100

Figure 2.10: Wall 0101
20

Figure 2.11: Wall 0110

Figure 2.12: Wall 0111

Figure 2.13: Wall 1001

Figure 2.14: Wall 1010

Figure 2.15: Wall 1011

21

Figure 2.16: Wall 1100

Figure 2.17: Wall 1101

Figure 2.18: Wall 1110

Figure 2.19: Wall 1111
The first bit represents whether connection is to be made on the right,
second whether on the top, third whether on the left and fourth whether
on the bottom. As wall 0000 would be very small and hard to maneuver
around for user, drawing of such is unsupported. I have actually tested
moving around such and even my manual and keyboard skills are relatively
good, I found it hard to move around such.
Algorithm deciding which type of wall is presented below:
1
2
3
4

def walltypecheck ( location ) :
r = t = l = b = 0
# n o t e t h a t l e t t e r s c o r r e s p o n d t o Right Top L e f t Bottom
i f l o c a t i o n [ 0 ] != 0 :

22

5
6
7
8
9
10
11
12
13
14
15
16

l e v e l [ l o c a t i o n [ 0 ] − 1 ] [ l o c a t i o n [ 1 ] ] ==
l = 1
i f l o c a t i o n [ 0 ] != 3 1 :
i f l e v e l [ l o c a t i o n [ 0 ] + 1 ] [ l o c a t i o n [ 1 ] ] ==
r = 1
i f l o c a t i o n [ 1 ] != 0 :
i f l e v e l [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] − 1 ] ==
t = 1
i f l o c a t i o n [ 1 ] != 3 1 :
i f l e v e l [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] + 1 ] ==
b = 1
return str ( r ) + str ( t ) + str ( l ) + str (b)
if

wall :

wall :

wall :

wall :

17

For reference of how level data is stored see section 2.4. This algorithm
returns type of wall that would fit in the spot location provided as an argument while calling the function. Output format is a string corresponding
with wall names described above.

2.3.2

Player

Player is represented by an iconic PacMan figure of my own design (to
avoid direct copying of work of others). The tile rotates depending on the
direction of player’s movement so that the ’mouth’ is always facing forward
as per requirement 1c. Color has been slightly darkened as I find this design
a little bit nicer than the original while still complying with requirement 1b.

Figure 2.20: Player sprite

2.3.3

Ghosts

There are three types of ghosts in the game, red, green and blue. They are
similar in design, though they behavior is different. (described later)

Figure 2.21: Red ghost sprite
23

Figure 2.22: Green ghost sprite

Figure 2.23: Blue ghost sprite

2.3.4

Eatables

Coins
Coin spawning works a little bit different than spawning other tiles, which is
described later. They actually appear in every tile not designated as ’wall’,
’heart’ or ’empty’. They are static and their sprites are killed when player
enters their tile resulting in coins-eaten counter value increasing.

24

Figure 2.24: Coin graphics
Hearts
Hearts are similar to coins in terms of being eaten, but they spawn in designated places and their consumption increases lives counter.

2.3.5

Empty tiles

These tiles are actually not drawn. They only act as an abstract concept
to hold information that coin is not to be drawn on this particular grid tile.
Player and ghost can move through this tile. For user these appear as plain
dark blue space - the color of the background.

2.4
2.4.1

Levels
Permanent storing

It took me a while to actually figure out how to store level blueprints. The
container had to be a 32x32 matrix of values. Python lists of lists of vari25

ables would actually be the most efficient way to store types of tiles on each
position in the grid. I have actually tried this approach back when my original board was still 64x64 tiles and it didn’t take me 10 tiles of brackets and
commas to figure out, that maybe this approach is most efficient for storing,
but it is absolutely to slow to prepare the level of 4096 tiles. I have decided
that I need an editing software for these grids. Then I understood that my
levels, grids of values are actually bitmaps. I have prepared an exemplar
of a level in GIMP and using my previous experience with Pillow module
I have prepared a script to load these bitmaps to my Python program. It
1 th
all took less time that it would take to fill
of that list of lists of values
10
manually.

Figure 2.25: An exemplar of a level being edited in the GIMP software
Each tile has its representation in a particular color in RGB notation:
Empty tile
Wall
Coin
Player
Red Ghost
Green Ghost
Blue Ghost

2.4.2

(255, 255, 255)
(0, 0, 0)
(255, 255, 0)
(255, 0, 0)
(200, 100, 100)
(0, 255, 0)
(0, 0, 255)

Storing while in game

Do you remember my first concept for the most optimal storage of levels
mentioned earlier? Well, that didn’t work for storing levels as files... But
in game while loaded in RAM - works like a charm. List of lists of integers,
26

just like that:
[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
[1, 4, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]

27

Where every value represents a different type of tile.
Empty tile
Wall
Coin
Player
Red Ghost
Green Ghost
Blue Ghost

2.4.3

0
1
2
3
4
5
6

Interpreting

Figure 2.26: First tests of interpretation of level files. Note that coins are
formed into letters LU, RU, LB, RB as in words Left, Right, Upper, Bottom
to load the tiles in the right orientation. Old 64x64 grid is used.

28

These tables are then interpreted for program to know where to place which
sprites, therefore the following algorithm is used:
1
2
3
4
5
6
7
8
9
10
11

if

l e v e l [ column ] [ row ] = w a l l
spawn w a l l a t l o c a t i o n column , row
e l i f l e v e l [ column ] [ row ] = p l a y e r
spawn p l a y e r a t l o c a t i o n column , row
e l i f l e v e l [ column ] [ row ] = c o i n
spawn c o i n a t l o c a t i o n column , row
e l i f l e v e l [ column ] [ row ] = g h o s t
gtype = check g h o s t c o l o r
spawn g h o s t o f c o l o r gtype a t l o c a t i o n column , row
e l i f l e v e l [ column ] [ row ] = h e a r t
spawn h e a r t a t l o c a t i o n column , row

12

2.4.4

Designing the levels

Process of level design is quite easy and only limitation one needs to remember is that all coin - having tiles must be accessible by a player - not
surrounded by a wall. The rest is just a subjective approach to the difficulty. As not all ghosts have to be used, the first few levels have one or two
ghosts at most, making them easier. Through alpha testing I have noticed
that long passages are traps, as one ghost may approach player from one
side and other from the other and there is nowhere to hide. Also it’s easier
for ghosts to navigate through complex maze and these might be fingertangling even for advanced players. See Figure 2.25 for a screenshot of a
design process.

2.4.5

User-defined levels

As levels can be created using a very basic bitmap editing software, user
might actually add their own levels. And use them instead of the built-in
ones.
Self-adding levels instruction is available in Appendix X. TODO:reference
to right appendix TODO:instruction

2.4.6

Progressing to the next level

When player eats all coins, they advance to the next level. At this stage a
message screen (described later) appears and all level - loading procedures
are called. Also counters of coins eaten and total are reset at this point.
If the level completed was the last level, a congratulations screen is
displayed and the game eventually quits.
See Section 2.6 for reference on messages signaling level change and completing the game.

29

2.5

Gameplay scheme

The game works on a concept of a loop, that (when run on a sufficiently fast
machine) executes 60 times per second. During that time multiple conditions
are checked and different procedures are called.

2.5.1

Introduction to the concept of time segments

Figure 2.27: Scheme depicting relation between a time segment and parts
It’s actually not required to compute some values every each of these 60
1 th
loop repetitions per second. An example - ghost moves
of a tile in that
10
time, it still can’t turn so its path to the unchanged player location will
remain the same. That’s why I have introduced ”Time segments”. These
are discrete representations of time period which is required for a ghost or
a player to move a length of one tile. As ghost are slower, they have 5 of
these in a second and player has 6.
Whilst processing single frames is still needed, these were called parts,
whilst introducing ’part’ variable determining which part of time segment is
currently executed. See Figure 2.27 for reference.

2.5.2

Player movement

Every player’s time segment the following code is called:
1

# −−−−− c h e c k i n g p r e s s e d k e y s −−−−−

30

2
3
4

k e y s = pygame . key . g e t p r e s s e d ( )
# −−−−− w a l l c o l l i s i o n check −−−−−
surroundings = walltypecheck ( player . location )

5

It’s worth noting that I have reused walltypecheck to look for surroundings
of the player for walls. See section 2.3.1 for reference on how this algorithm
works.
Then check is performed whether player’s move is legit (wall does not
obstruct it).
1
2
3
4
5
6
7
8

if

l e f t key p r e s s e d and t i l e t o t h e l e f t i s not a w a l l :
p l a y e r . move ( ’ l e f t ’ , p l a y e r p a r t )
e l i f r i g h t key p r e s s e d and t i l e t o t h e r i g h t i s not a w a l l :
p l a y e r . move ( ’ r i g h t ’ , p l a y e r p a r t )
e l i f up key p r e s s e d and t i l e above i s not a w a l l :
p l a y e r . move ( ’ up ’ , p l a y e r p a r t )
e l i f down key p r e s s e d and t i l e below i s not a w a l l :
p l a y e r . move ( ’ down ’ , p l a y e r p a r t )

9

Please note usage of the player part variable. It is the value of frames that
have passed since last player segment begun (as described in Section 2.5.1).
It’s useful to determine whether a new time segment is to be started and
for player’s moving routine to know at which part of tile it should position
player’s sprite inducing a fluency of movement.

Figure 2.28: Diagram showing how tasks are executed either once per time
segment or once per part

31

2.5.3

Ghost movement

Ghost movement is a far more complex algorithm than player’s movement
though it uses same concept of time segments.
As mentioned in Success Criteria 2a, I wanted the ghosts to be more
intelligent than the originals. I have read (Reference 1) that the original
algorithm is really primitive. It checks from which of surrounding tiles ghost
will be straight-line closest to the player and moves there.
The graph
First idea of mine was to make the ghost actually pick the shortest path to
the player. That would have to involve implementation of a graph and a
pathfinding algorithm.
As I already had my level-keeping structure in place I have decided to
use a similar one to store my graph. It is represented as a list of lists of lists
of location tuples. It looks confusing so...
A list (index i) of lists (index j) is used so that all nodes accessible from node
of location (i, j) can be stored. Then that next list stores tuples (x, y) of
locations accessible from that node. Object is named ’thegraph’ throughout
the program (as it is the only graph implementation in it). Note that it is
a global object.
It’s obviously individual for each level and is built every time a level is
loaded. Through the following routine:
1
2
3
4
5
6
7
8
9
10

11
12
13

14
15
16

17
18
19

def graphbuilder () :
g l o b a l l e v e l , thegraph
thegraph = [ [ [ ] f o r i in range (32) ] f o r j in range (32) ]
f o r i in range (32) :
f o r j in range (32) :
i f l e v e l [ i ] [ j ] != w a l l :
location = [ i , j ]
i f l o c a t i o n [ 0 ] != 0 :
i f l e v e l [ l o c a t i o n [ 0 ] − 1 ] [ l o c a t i o n [ 1 ] ] !=
wall :
t h e g r a p h [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] ] += [ [ l o c a t i o n
− 1 , location [ 1 ] ] ]
i f l o c a t i o n [ 0 ] != 3 1 :
i f l e v e l [ l o c a t i o n [ 0 ] + 1 ] [ l o c a t i o n [ 1 ] ] != w a l l :
t h e g r a p h [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] ] += [ [ l o c a t i o n
+ 1 , location [ 1 ] ] ]
i f l o c a t i o n [ 1 ] != 0 :
i f l e v e l [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] − 1 ] != w a l l :
t h e g r a p h [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] ] += [ [ l o c a t i o n
location [1] − 1]]
i f l o c a t i o n [ 1 ] != 3 1 :
i f l e v e l [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] + 1 ] != w a l l :
t h e g r a p h [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] ] += [ [ l o c a t i o n
location [1] + 1]]

20

32

[0]

[0]

[0] ,

[0] ,

Pathfinding
This part I found actually the hardest. All my previous experience with
graphs and pathfinding was actually from old times when my favorite language was C++. Apparently when I switched to Python, my rusty knowledge on the topic had to be refreshed. My first approach (a stupid one) was
to use DFS search to check all possible paths and decide which one to use.

Figure 2.29: Diagram showing order of nodes visits starting from node 1
using DFS algorithm Source: wikipedia.org
It was a rather simple recursion.
1
2
3
4
5
6

7

d e f f i n d p a t h ( s t a r t , end , path ) :
append s t a r t t o path
i f s t a r t == end :
r e t u r n path
else :
f o r neighbour in neighbours ( s t a r t ) : # neighbours e a s i l y
o b t a i n e d from t h e g r a p h
f i n d p a t h ( neighbour , end , path )

8

That was stupid and very slow, as I have noticed that my graph is not actually a tree and paths may have cycles, this process never actually worked.
And then I realized that a more appropriate solution was to use BFS
and implement whether a new node was actually visited before.

33

Figure 2.30: Diagram showing order of nodes visits starting from node 1
using BFS algorithm Source: wikipedia.org
I also dropped recursion as advised by online forums... Maybe recursion is a way in C++ but in Python it apparently is really slow. Also my
own testing of recursive approach sometimes lead to stack overflows, which
disqualified this method completely.
A queue of nodes to visit was implemented and new algorithm came to
life. It was fast but its output of a complete path to player was actually
an overkill - why would I need it if it will become obsolete in the next time
segment when player location changes?
The next iteration actually begins BFSing from the player, until it finds
any of the tiles surrounding the ghost. It then returns location of such tile
- next tile ghost has to move to.
1
2
3
4
5
6
7
8
9
10
11
12
13
14

d e f f i n d n e x t m o v e ( s t a r t , end , f o r b i d d e n ) :
visited = []
queue = [ ]
n e i g h b o u r s = t h e g r a p h [ s t a r t [ 0 ] ] [ s t a r t [ 1 ] ] . copy ( )
queue . append ( [ end [ 0 ] , end [ 1 ] ] )
v i s i t e d . append ( end )
f o r p o i n t i n queue :
i f p o i n t not i n v i s i t e d :
v i s i t e d . append ( p o i n t )
i f point in neighbours :
return point
f o r node i n t h e g r a p h [ p o i n t [ 0 ] ] [ p o i n t [ 1 ] ] :
i f node not i n v i s i t e d :
queue . append ( node )

15

34

As this approach worked, I was satisfied with its speed and overall performance. Then in alpha testing I found a strange occurrence I haven’t
noticed in the original PacMan - ghosts could reverse.
I didn’t like it, so the algorithm had to exclude ghost’s previous location
from its neighboring tiles. The next version looked like this:
1
2
3
4
5
6
7
8
9
10
11
12
13
14

15

d e f f i n d n e x t m o v e ( s t a r t , end , f o r b i d d e n ) :
visited = []
queue = [ ]
n e i g h b o u r s = t h e g r a p h [ s t a r t [ 0 ] ] [ s t a r t [ 1 ] ] . copy ( )
n e i g h b o u r s . remove ( [ f o r b i d d e n [ 0 ] , f o r b i d d e n [ 1 ] ] )
queue . append ( [ end [ 0 ] , end [ 1 ] ] )
v i s i t e d . append ( end )
f o r p o i n t i n queue :
i f p o i n t not i n v i s i t e d :
v i s i t e d . append ( p o i n t )
i f point in neighbours :
return point
f o r node i n t h e g r a p h [ p o i n t [ 0 ] ] [ p o i n t [ 1 ] ] :
i f node not i n v i s i t e d and node != [ f o r b i d d e n [ 0 ] ,
forbidden [ 1 ] ] :
queue . append ( node )

16

Difference between ghosts
As I have generated some levels and started testing, I found out that if two
ghost share location, they effectively become one as their optimal paths will
be the same and they will always move the same way. That of course wasn’t
the effect I wanted, I had to figure out how to make the ghosts behave
different. But how to make ghosts both smart and not going straight for the
player? Internet for the win, meme pages came with help.

35

Figure 2.31: Popular meme. Source: pinterest.com
Now enlightened by a piece of digital artwork originating from Star Wars
(see Figure 2.31), I decided that my ghosts have to behave like they were
to surround the player. How to achieve such effect? I turned to the original
PacMan solution - not moving to the exact tile the player occupies. A
decision was made to leave the red ghost originally smart while blue and
green ghosts were to move to tiles shifted by (-2, -2) and (2, 2) vectors from
the player. The result was amazing, ghosts seemed to move separately while
away from the player, when they approach it, I had a sense that this is not
what I programmed, They hunt in a pack! I had an authentic experience
of ghosts setting a trap, green and blue were blocking my exit routes, when
red went straight for me.
But it sometimes crashed, I wondered what was the case and then I
found out that the ghosts were actually trying to go to a tile, which is either
a wall (inaccessible) or outside the board (object level was referenced with
an invalid index, either negative or exceeding it’s length). I had to write a
piece of algorithm to look for a nearest tile that is actually not wall.
1
2
3
4
5
6

def f i n d n e a r e s t n o t w a l l ( point ) :
i f point [ 0 ] > 31:
p o i n t [ 0 ] = 31
i f point [ 0 ] < 0:
point [ 0 ] = 0
i f point [ 1 ] > 31:

36

7
8
9
10
11
12
13
14
15
16
17
18
19
20
21

p o i n t [ 1 ] = 31
i f point [ 1 ] < 0:
point [ 1 ] = 0
radius = 1
i f l e v e l [ p o i n t [ 0 ] ] [ p o i n t [ 1 ] ] != w a l l :
return point
w h i l e True :
f o r i i n r a n g e ( p o i n t [0] − r a d i u s , p o i n t [ 0 ] + r a d i u s ) :
f o r j i n r a n g e ( p o i n t [1] − r a d i u s , p o i n t [ 1 ] + r a d i u s ) :
try :
i f l e v e l [ i ] [ j ] != w a l l :
return [ i , j ]
except IndexError :
pass
r a d i u s += 1

22

It first moves the point to the nearest one on the board (lines 2 to 9). Then
it checks whether such point is a wall, if not, returns it (lines 11 and 12). If
it was a wall it starts searching surroundings of such point in a fixed radius,
starting from 1. First point it finds not to be wall is then returned.
Later it had to be implemented in the pathfinding algorithm, which now
looks like this:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

16

d e f f i n d n e x t m o v e ( s t a r t , end , f o r b i d d e n ) :
visited = []
queue = [ ]
end = f i n d n e a r e s t n o t w a l l ( end )
n e i g h b o u r s = t h e g r a p h [ s t a r t [ 0 ] ] [ s t a r t [ 1 ] ] . copy ( )
n e i g h b o u r s . remove ( [ f o r b i d d e n [ 0 ] , f o r b i d d e n [ 1 ] ] )
queue . append ( [ end [ 0 ] , end [ 1 ] ] )
v i s i t e d . append ( end )
f o r p o i n t i n queue :
i f p o i n t not i n v i s i t e d :
v i s i t e d . append ( p o i n t )
i f point in neighbours :
return point
f o r node i n t h e g r a p h [ p o i n t [ 0 ] ] [ p o i n t [ 1 ] ] :
i f node not i n v i s i t e d and node != [ f o r b i d d e n [ 0 ] ,
forbidden [ 1 ] ] :
queue . append ( node )

17

Note line 4. where final point is substituted with a one closest to it being
actually accessible.
Calling pathfinding algorithm
Now, every ghosts’ time segment (note that all ghosts share a single time
segment), a new destination tile is calculated for each ghost and pathfinding
is called to determine which tile should the ghost move to throughout the
time segment.
37

1
2
3

4
5
6
7

8
9
10
11
12

13

f o r ghost in g h o s t s l i s t :
i f g h o s t . c o l o r == ’ r e d ’ :
ghost . n e x t t i l e = find next move ( ghost . location , player .
location , ghost . p r e v i o u s l o c a t i o n )
e l i f g h o s t . c o l o r == ’ b l u e ’ :
ghost . n e x t t i l e = find next move ( ghost . location ,
[ player . location [ 0 ] + 2 ,
player . location [ 1 ] +
2] ,
ghost . p r e v i o u s l o c a t i o n )
e l i f g h o s t . c o l o r == ’ g r e e n ’ :
ghost . n e x t t i l e = find next move ( ghost . location ,
[ player . location [ 0 ] − 2 ,
player . location [ 1 ] −
2] ,
ghost . p r e v i o u s l o c a t i o n )

14

Note how find next move function takes arguments of:
1. Ghost location
2. Target location
3. Previous ghost location - forbidden tile as ghosts can’t reverse.
Ghosts speed
As I had ghosts chasing me, I have figured out that the player actually
can’t outrun them. And every suboptimal move of the player led to red
ghost getting closer and closer. I had the smartest ghost possible, but it
had an advantage of having no means of being killed. It was a too powerful
opponent. I didn’t want to add power-ups for the player to either become
faster or to be able to frighten/kill the ghosts. Instead, as derived from the
5 th
Interview (see Section 1.4), I decided to make the ghosts move at
of
6
the player’s speed. I found the gameplay to be quite optimal and actually
started playing the game which at this stage was only running from the
ghost. But with a stopwatch I was challenged to keep my distance from
them for quite a long time. I finally knew that this is what I was aiming for.

2.5.4

Handling movement animation

This section is common for both ghosts and a player as it actually derives
from the same code. As mentioned in Section 2.5.1, the part part is a
smaller piece of time segment. During a single part no routes are computed
for ghosts, they only move from one tile to another, being able to actually
be rendered in between these tiles to make the Movables (ghosts + player
sprites) move fluently.

38

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

16

17
18
19
20

d e f move ( d i r e c t i o n ,
segmentsize ,
part ) :
# handling multiple d i r e c t i o n formats
i f d i r e c t i o n == ’ up ’ o r d i r e c t i o n == ( 0 , 1 ) :
s p e e d = ( 0 , −1)
e l i f d i r e c t i o n == ’ down ’ o r d i r e c t i o n == ( 0 , −1) :
speed = (0 , 1)
e l i f d i r e c t i o n == ’ l e f t ’ o r d i r e c t i o n == ( −1 , 0 ) :
s p e e d = ( −1 , 0 )
e l i f d i r e c t i o n == ’ r i g h t ’ o r d i r e c t i o n == ( 1 , 0 ) :
speed = (1 , 0)
p a r t 2 = ( p a r t +1) / s e g m e n t s i z e #a s p a r t s a r e numbered from 0
#r e c t p a r a m e t e r s o f a Movable a s implemented i n pygame
r e c t . x , r e c t . y = ( l o c a t i o n [ 0 ] + speed [ 0 ] ∗ part2 ) ∗
tile width ,
( l o c a t i o n [ 1 ] + speed [ 1 ] ∗ part2 ) ∗
tile width
i f p a r t == s e g m e n t s i z e − 1 :
#i f movement came t o t h e end update l o c a t i o n
l o c a t i o n = l o c a t i o n [ 0 ] + speed [ 0 ] ,
l o c a t i o n [ 1 ] + speed [ 1 ]

21

1. Speed vector is derived from parameter ’direction’ (lines 4-12)
2. part2 is calculated - fraction of progress of the movement to be completed in this part (line 13)
3. Movable sprite is moved to new position (lines 14-16)
4. If the actual movement came to an end and a Movable is in a center
of a next tile location is updated (lines 17-20)

39

Figure 2.32: Diagram showing how tasks are executed either once per time
segment or once per part (for a ghost)
See Figure 2.28 for the same for player.

2.5.5

Eating

Eating of both coins and hearts (Eatables) was easy to implement in terms
of detection, but I had to look up how to destroy eaten sprites in the pygame
documentation. I found that Sprites may be killed, which seemed to be an
optimal solution to that problem. Therefore every player’s time segment the
following routine is called.
1
2
3
4
5
6
7

for eatable in eatables :
i f e a t a b l e . l o c a t i o n == p l a y e r . l o c a t i o n :
i f e a t a b l e == h e a r t :
l i f e s += 1
i f e a t a b l e == c o i n :
c o i n s e a t e n += 1
eatable . k i l l ()

8

For every eatable is checked for occupying the same tile as player.
Then if it is a heart, player gains a life,
if it was a coin, coins eaten counter increases.
Eatable sprite is killed.

40

2.5.6

Getting killed

Killing a player is fairly similar to eating... It’s just checking for collision
with a Ghost instead of an Eatable. It’s also called every player’s time
segment or every ghosts’ time segment. Following routine is then called:
1
2
3
4
5
6
7
8
9

f o r ghost in ghosts :
i f g h o s t . l o c a t i o n == p l a y e r . l o c a t i o n :
l i v e s −= 1
i f l i v e s == 0 :
p u l l Game Over s c r e e n
Respawn e v e r y Movable
Reset p ar t s
Wait 5 s
Continue game

10

For every ghost a collision with player is checked, if such is detected, process
of dying begins.
Life is subtracted from lives counter.
If player has no more lives the game ends.
If there are more lives, all movables return to their original position (described in Section 2.5.7) and part counters are reset.
Game waits 5 seconds to let the user cope with the loss, and continues.

2.5.7

Respawning after a loss of life

This is a relatively simple process of putting all Movables to their initial position and making them not preserve their speed. It can be easily described
with a following code:
1
2
3

f o r Movable i n Movables :
Movable . l o c a t i o n = Movable . i n i t i a l l o c a t i o n
Movable . s p e e d = ( 0 , 0 )

4

2.6

Types of message screens

Messages present throughout the game are displayed in a way that prevents
any game event, from occurring unless the message is dismissed by pressing
space.
It’s done through occupying the main thread with checking for spacebar
being pressed.

41

Figure 2.33: Diagram showing how game is halted until message is dismissed
using spacebar

Figure 2.34: Exemplar of the message screen appearing in a window rendered
in Ubuntu Gnome graphical environment

42

2.6.1

Tutorial

TODO: Photo of the screen These will be actually completed when I will
have time to input actual strings, whilst more critical game parts may be
developed earlier.
I remind that I had to make 13 months worth of coursework from 3 subjects
in 3 months.

2.6.2

Loss of life

TODO: Photo of the screen

2.6.3

Completing a level

Figure 2.35: Message displayed after completing a level. Shown in a game
window rendered in the Ubuntu Gnome graphical environment.

2.6.4

Loosing the game

TODO: Photo of the screen
43

2.6.5

Completing the entire game

TODO: Photo of the screen

2.7

Testing

I have decided to use three stages of testing, namely zero, alpha (α) and
beta (β).

2.7.1

zero-testing

This stage was introduced while testing single functions and procedures implemented through the game during the development process. It consisted
of mostly running code as-is while writing it using PyCharm. Sometimes
I haven’t even use debugger in favor of print function to enlist values of
variables. This phase commenced until all modules of the game were actually prepared, despite being containing minor bugs that didn’t immediately
throw an error. At the end of this stage, the game was playable.

2.7.2

α-testing

This was the stage of extensively playing the game to see whether all functions appear to be working correctly. Note the use of word ’appear’ - code
wasn’t actually read at this stage in look for bugs, only user experience was
assessed. I have tried different approaches at playing, to make the game
algorithms experience different user input. From staying perfectly still to
going straight for a ghost, I have played the game checking the following:
1. Getting killed by the ghost approaching from different angles.
2. Eating Eatables from different angles.
3. Trying to pass through numerous walls.
4. Moving the player in different directions repeatedly to check if ghosts
get confused and the gameplay remains fluent.
5. Manual counting of coins eaten to see if it matches the counter value.
6. Checking whether all graphics render well, by creating each wall type
and each possible sprite.
7. Providing program with unexpected input of unassigned keys, mouse
clicks and even connecting a gamepad.

44

2.7.3

β-testing

This was a stage of testing, during which all major bugs were resolved and
the assessment was focused on user experience. Following procedures were
performed:
1. Smoothness of animations was checked on different computers, running
different OSs.
2. Graphics quality was assessed by an independent body, namely my
sister.
3. Actual playing was performed and all levels were played. Each level
was actually completed, but never in a single sitting, proving that
game indeed can be completed, though it is considerably hard.
4. Different players were used to test the game play.
5. Quality of input controls was assessed.

45

Chapter 3

Implementation
In this section the detailed description of how the game files were created is
provided.

3.1

Programming tools

Whole development of the game, as mentioned in Section 1.3, was done
using a Ubuntu running computer and legally obtained tools I didn’t have
to pay for, namely opensource, freeware or free for education software.

3.1.1

PyCharm

I used, in my opinion, a brilliant Python IDE called PyCharm. Developed
by a company JetBrains and obtained under Free for Education license for
the entirety of the project development. The program has a lot of useful
functions, which made my work easier and admittedly contributed to me
learning how to code more efficiently.

46

Figure 3.1: Pycharm window rendered in Ubuntu Gnome environment with
Pycman project loaded.

3.1.2

GIMP

GIMP software was used to develop graphical resources for the game as well
as for this document. It’s an open source community-developed tool for
graphics manipulation, which sometimes is referred as the free alternative
to the Adobe Photoshop, with advanced functions and ability to edit images
with Alpha channel, resulting in capacity to make ghost images semitransparent. See Figure 2.21 for reference.

3.1.3

Git

Git is a popular tool for VCS (Version Control System). My previous experience with programming and mostly teamwork made me use it as an
obvious choice for keeping my project files. I used free Github for Education account and github.com servers for storing my files. Admittedly it was
really useful when I had to revert some advanced changes or look up how
something worked earlier, as it worked better. Basically speaking - it made
mistakes less painful.

3.1.4

TeXstudio

TeXstudio was used to write this document. LATEXwith its excellent reference system as well as professional look was the most appropriate tool in
my opinion.

47

Figure 3.2: TeXstudio window rendered in Ubuntu Gnome environment with
this document loaded.

3.1.5

Other tools

Minor other programs were used for writing this documentation, mostly for
obtaining screenshots and producing flowcharts.

3.2
3.2.1

Interpreter and its modules
Virtual Environment

To keep my computer clean and my main /usr/bin Python interpreter free of
heavy, not often used modules as Pygame I have decided to create a separate
interpreter instance using Virtualenv tool.

3.2.2

Modules

Modules used by the game are as follows:
• Pygame - for graphics rendering and input control. Origin of the Sprite
class.
• Pillow A.K.A. PIL - for loading level files
• time - origin of the function sleep for delaying certain actions.

48

3.3

Project structure

I have decided to make the project structure as professionally organized as
possible. Therefore I have divided program into resource files and Python
files, keeping the first separate in a different folder. Documentation and its
resources - graphics are also stored separately.

Figure 3.3: Abbreviated directory structure layout
Reason for additional Python files will be provided within this Chapter.

49

3.4

Classes

Figure 3.4: Project class diagram

50

3.4.1

GameObject

As whole game is written around pygame environment I have decided to
utilize Pygame Sprite class for all objects (excluding text) rendering on the
screen. To facilitate some concepts I assumed in the Design stage I had to
add a GameObject class.
Class code:
1
2
3
4
5
6
7

c l a s s GameObject ( pygame . s p r i t e . S p r i t e ) :
def
i n i t ( self , location ) :
super () .
init
()
s e l f . image = None
s e l f . location = location
s e l f . initiallocation = location
s e l f . r e c t = None

8
9

10
11
12
13
14

d e f s e t i m a g e ( s e l f , image , s i z e=r e s o u r c e s . c o n s t a n t s . b o x S i z e ,
r o t a t i o n =0) :
s e l f . image = pygame . image . l o a d ( r e s o u r c e s . p a t h s . image [ image ] )
s e l f . image = pygame . t r a n s f o r m . s c a l e ( s e l f . image , s i z e )
s e l f . image = pygame . t r a n s f o r m . r o t a t e ( s e l f . image , r o t a t i o n )
s e l f . r e c t = s e l f . image . g e t r e c t ( )
s e l f . rect .x , s e l f . rect . y = s e l f . location [0 ] ∗ resources .
c o n s t a n t s . boxSegmentSize , s e l f . l o c a t i o n [ 1 ] ∗ r e s o u r c e s .
c o n s t a n t s . boxSegmentSize

15

The most important part of the class is the ’location’ attribute. It is an
(integer, integer) tuple storing information of location of the object in a grid,
as described in Section 2.2. Location is passed as a constructor argument.
It also provides facilities for easy setting the Sprite image.

3.4.2

Eatable

Eatable class is a standard class for Coins and Hearts (see Section 2.3.4
for Coins and Hearts definitions). Its init () method sets proper image
depending on its type, which it takes as an argument.
Class code:
1
2
3
4
5
6
7
8

c l a s s E a t a b l e ( GameObject ) :
def
i n i t ( s e l f , type , l o c a t i o n ) :
super () .
i n i t ( location )
s e l f . type = type
i f type == ” c o i n ” :
s e l f . setimage ( ” coin ” , resources . constants . e a t a b l e S i z e )
e l i f type == ” h e a r t ” :
s e l f . setimage ( ” heart ” , resources . constants . e a t a b l e S i z e )

9

51

3.4.3

Wall

Wall class is fairly simple - during declaration it takes arguments of location
in the grid and the type of the Wall. (For reference on types of walls see
Section 2.3.1 and Section 2.3.1 for reference on type determination.)
Class code:
1
2
3
4

c l a s s Wall ( GameObject ) :
def
i n i t ( s e l f , l o c a t i o n , type ) :
super () .
i n i t ( location )
s e l f . s e t i m a g e ( ’w ’+s t r ( type ) )

5

3.4.4

Movable

Movable is the most complex class deriving from GameObject. It is a
blueprint for both Ghosts and the Player, which in contrary to other GameObjects are not static and may move or reset their position to initial (see Section
2.5.7 for information about Movable respawning). It has an additional attribute of ’speed’ which is an (integer, integer) tuple with information in
which direction (x, y) is the Movable moving. Naturally it has a ’move’
method that processes these information accordingly. This method takes
following arguments:
• ’direction’ - processed to produce a valid ’speed’ attribute,
• ’segmentsize’ - number of frames per time segment (See Section 2.5.1
for reference.)
• ’part’ - part/frame of the movement (See Sections 2.5.1 and Figure
2.27 for reference.)
Method for resetting is fairly straightforward - object initializes itself back
in the initial position, exactly how it started, with the same initialization
method.
Class code:
1
2
3
4
5

c l a s s Movable ( GameObject ) :
def
i n i t ( self , location ) :
super () .
i n i t ( location )
s e l f . image = None
s e l f . speed = (0 , 0)

6
7

8

d e f s e t i m a g e ( s e l f , image , s i z e=r e s o u r c e s . c o n s t a n t s . movableSize
, r o t a t i o n =0) :
s u p e r ( ) . s e t i m a g e ( image , s i z e , r o t a t i o n )

9
10

11

d e f move ( s e l f , d i r e c t i o n , s e g m e n t s i z e , p a r t=r e s o u r c e s .
co nst ant s . playerTimeSegmentSize − 1) :
i f d i r e c t i o n == ’ up ’ o r d i r e c t i o n == ( 0 , 1 ) :

52

12
13
14
15
16
17
18
19
20

21
22

s e l f . s p e e d = ( 0 , −1)
e l i f d i r e c t i o n == ’ down ’ o r d i r e c t i o n == ( 0 , −1) :
s e l f . speed = (0 , 1)
e l i f d i r e c t i o n == ’ l e f t ’ o r d i r e c t i o n == ( −1 , 0 ) :
s e l f . s p e e d = ( −1 , 0 )
e l i f d i r e c t i o n == ’ r i g h t ’ o r d i r e c t i o n == ( 1 , 0 ) :
s e l f . speed = (1 , 0)
p a r t 2 = ( p a r t +1) / s e g m e n t s i z e
s e l f . r e c t . x , s e l f . r e c t . y = ( s e l f . l o c a t i o n [ 0 ] + s e l f . speed [ 0 ]
∗ r e s o u r c e s . constants . speedFactor ∗ part2 ) ∗ r e s o u r c e s .
c o n s t a n t s . boxSegmentSize , ( s e l f . l o c a t i o n [ 1 ] + s e l f . s p e e d [ 1 ] ∗
r e s o u r c e s . constants . speedFactor ∗ part2 ) ∗ r e s o u r c e s .
c o n s t a n t s . boxSegmentSize
i f p a r t == s e g m e n t s i z e − 1 :
s e l f . l o c a t i o n = s e l f . l o c a t i o n [ 0 ] + s e l f . speed [ 0 ] ∗
r e s o u r c e s . constants . speedFactor , s e l f . l o c a t i o n [ 1 ] + s e l f .
speed [ 1 ] ∗ r e s o u r c e s . constants . speedFactor

23
24
25

def reset ( s e l f ) :
self .
init ( self . initiallocation )

26

3.4.5

Player

Descriptively, Player class is the template for the Player’s Sprite. I have
created a separate class for object that by definition should only exist in
one instance for simplicity. If all Movables are to be moved using same
routines - so should be the player. It also matches my objective to learn
how to program using the ’Object Oriented Programming’ paradigm. Class
constructor takes argument of location, as per standard Movable and sets
Sprite’s image as the yellow ball with ’mouth’. Notably this class only overrides Movable.move method in order to account for Player’s rotation (see
Requirement 1c). The rotation is determined using speed attribute and
stored as a degree value in ’rotation’ integer variable local to overridden
’move’ method. Then, within the same method, parent’s parent’s (Movable’s parent is GameObject) ’setimage’ method is invoked with an extra
argument, the rotation. This example nicely shows how inheritance works
in practice, a great advantage of OOP, which I learned this way.
Class code:
1
2
3
4

c l a s s P l a y e r ( Movable ) :
def
i n i t ( self , location ) :
super () .
i n i t ( location )
s e l f . setimage ( ’ player ’ , resources . constants . playerSize )

5
6

7
8

d e f move ( s e l f , d i r e c t i o n , p a r t=r e s o u r c e s . c o n s t a n t s .
p l a y e r T i m e S e g m e n t S i z e − 1 , p a r t s i z e=r e s o u r c e s . c o n s t a n t s .
ghostTimeSegmentSize ) :
rotation = 0
i f s e l f . s p e e d == ( 1 , 0 ) :

53

9
10
11
12
13
14
15
16

17

rotation = 0
e l i f s e l f . s p e e d == ( −1 , 0 ) :
r o t a t i o n = 180
e l i f s e l f . s p e e d == ( 0 , −1) :
r o t a t i o n = 90
e l i f s e l f . s p e e d == ( 0 , 1 ) :
r o t a t i o n = 270
super () . setimage ( ’ player ’ , r e s o u r c e s . constants . playerSize ,
rotation )
s u p e r ( ) . move ( d i r e c t i o n , s e g m e n t s i z e=r e s o u r c e s . c o n s t a n t s .
playerTimeSegmentSize , p a r t=p a r t )

18

3.4.6

Ghost

This class is used by all ghost objects. It derives from Movable with some
minor differences. During initialization, constructor accepts parameters of
grid location and ghost color (as a string). This class has a ’previouslocation’ (note it is not ’initiallocation’) parameter - this stores grid location of
the tile the ghost previously occupied. It is a significant factor for determining ghost’s path - as per Requirement 1h - ghosts cannot reverse. This
basically means that whenever path of the ghost to its target tile is determined, ’previouslocation’ tile is excluded from potential beginnings of such
path, which completely satisfies the Requirement. Move method has been
overriden to facilitate ’previouslocation’ change. So was ’reset’ method to
allow initialization with the same color. Class code:
1
2
3
4
5
6
7

c l a s s Ghost ( Movable ) :
def
i n i t ( self , location , color ) :
super () .
i n i t ( location )
s e l f . color = color
s e l f . n e x t t i l e = None
s e l f . s e t i m a g e ( c o l o r+ ’ g h o s t ’ )
s e l f . previouslocation = s e l f . location

8
9

10
11

d e f move ( s e l f , d i r e c t i o n , p a r t=r e s o u r c e s . c o n s t a n t s .
ghostTimeSegmentSize − 1 , p a r t s i z e=r e s o u r c e s . c o n s t a n t s .
ghostTimeSegmentSize ) :
s e l f . previouslocation = s e l f . location
s u p e r ( ) . move ( d i r e c t i o n , p a r t s i z e , p a r t )

12
13
14

def reset ( s e l f ) :
self .
i n i t ( s e l f . initiallocation , s e l f . color )

15

54

3.5

Resources

3.5.1

Constants

By now reader of this documentation should notice that Section 3.4 is full
of ’resources.constants.NAME’ statements. When writing the game I have
discovered that I input many hardcoded values in both class definitions and
the core program code, all of these were values that could change, worse, I
have changed them multiple times, throughout development. When I had
to change the size of board - namely substituting 64 with 32 in a few dozens
of lines I figured that I need to write all of those constants in a single place.
I added new file to the project - constants.py.
Here is its abbreviated content:
1
2
3
4
5
6
7
8
9
10
11
12
13
14

eatableSize = [20 , 20]
movableSize = [ 2 0 , 20]
playerSize = [20 , 20]
speedFactor = 1
windowSize = [ 6 4 0 , 6 6 0 ]
p l a y e r T i m e S e g m e n t S i z e = 10
ghostTimeSegmentSize = 12
t i l e W i d t h = 20
t i l e S i z e = [ tileWidth , tileWidth ]
f p s = 60
f o n t s i z e = 15
g a m e s i z e = 32
scatterSize = 2
totallevels = 5

15
16
17
18
19
20
21
22
23
24

leveldef = {
’ nothing ’ : 0 ,
’ wall ’ : 1 ,
’ coin ’ : 2 ,
’ player ’ : 3 ,
’ red ghost ’ : 4 ,
’ green ghost ’ : 5 ,
’ blue ghost ’ : 6 ,
}

25
26
27
28
29
30
31
32
33
34

editordef = {
’ nothing ’ : (255 , 255 , 255) ,
’ wall ’ : (0 , 0 , 0) ,
’ coin ’ : (255 , 255 , 0) ,
’ player ’ : (255 , 0 , 0) ,
’ red ghost ’ : (200 , 100 , 100) ,
’ green ghost ’ : (0 , 255 , 0) ,
’ b l u e g h o s t ’ : (0 , 0 , 255)
}

35

It consists of numerical constants used throughout the game. This basically
serves as settings - if I realize that player’s Sprite appears to small to com55

fortably navigate it, I can change its size in a single place without worrying
that somewhere in the code I left one value unchanged and, for example
player will be able to move through walls. Names of these constants are
very descriptive so that core code’s readability doesn’t suffer from using this
method. I even think that it’s more readable with constants used rather
than hardcoded values.
To use constants within any part of the code following import statement
must be used.
1

import r e s o u r c e s

2

To invoke a constant following code must be used: (with an example of an
’fps’ constant)
1

resources . constants . fps

2

Here is a list of most notable constants used in this project:
• eatableSize - x, y size of an image of object of class Eatable (in pixels)
• movableSize - x, y size of an image of object of class Movable (in pixels)
• playerSize - x, y size of an image of object of class Player (in pixels)
• speedFactor - integer value that can be used to tune Movables’ speed
on low performance platforms
• windowSize - size of game window in pixels (note, this is not the size
of the board)
• playerTimeSegmentSize - number of frames/parts per Player’s Time
Segment (see Section 2.5.1 for reference) This value can be used to
tune Player’s speed.
• ghostTimeSegmentSize - number of frames/parts per Ghosts’ Time
Segment (see Section 2.5.1 for reference) This value can be used to
tune Ghosts’ speed.
• tileWidth - this is a single integer value representing width of a single
tile (see Section 2.2 for reference on tiles) in pixels.
• tileSize - this is an iterable size of the tile in x,y format (unit is pixels).
For square tiles it is equal to [tileWidth, tileWidth]
• fps - desired value of Frames Per Second displaying on screen. Can
be modified together with speedFactor to run the game on slower machines.
• fontsize - determines size of the font used in the game in points
56

• gamesize - number of tiles per boards edge. Note that the game has a
total of gamesize2 tiles.
• scatterSize - As described in Section 2.5.3 - two of the ghosts don’t
chase the Player directly, they follow an optimal path to tiles shifted by
a specific vector from the Player’s location. This constant represents
an absolute value of one axis component of this vector. Namely, one
ghost’s target is shifted by (scatterSize, scatterSize) and the other’s
by (-scatterSize, -scatterSize)
• totallevels - number of levels available
• editordef - dictionary that defines what type of tile is represented by
a particular color (see Section 2.4.1 for reference on how levels are
stored) in level files. Colors are represented by (Red, Green, Blue)
tuples.
• leveldef - dictionary that defines what type of tile is represented by a
particular integer (see Section 2.4.2 for reference on how level files are
processed) in core game program.

3.6
3.6.1

Level processing
Reading bitmap files

As mentioned in Section 2.4.1 - levels are stored as bitmaps. To decode
these to format that is easily processed (see Section 2.4.2) the following file
has been written.
1
2

from PIL import Image
import r e s o u r c e s

3
4
5
6

7
8
9
10
11
12
13
14
15
16
17
18

def readlevel ( f i l e ) :
l e v e l = [ [ r e s o u r c e s . constants . l e v e l d e f [ ’ nothing ’ ] f o r i in
range ( r e s o u r c e s . constants . gamesize ) ] f o r j in range ( r e s o u r c e s
. constants . gamesize ) ]
im = Image . open ( r e s o u r c e s . p a t h s . l e v e l s + f i l e )
im . l o a d ( )
f o r c o l in range (0 , r e s o u r c e s . constants . gamesize ) :
f o r row i n r a n g e ( 0 , r e s o u r c e s . c o n s t a n t s . g a m e s i z e ) :
p i x e l = im . g e t p i x e l ( ( c o l , row ) )
i f p i x e l == r e s o u r c e s . c o n s t a n t s . e d i t o r d e f [ ” c o i n ” ] :
l e v e l [ c o l ] [ row ] = r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’ c o i n ’ ]
e l i f p i x e l == r e s o u r c e s . c o n s t a n t s . e d i t o r d e f [ ” w a l l ” ] :
l e v e l [ c o l ] [ row ] = r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’ w a l l ’ ]
e l i f p i x e l == r e s o u r c e s . c o n s t a n t s . e d i t o r d e f [ ” p l a y e r ” ] :
l e v e l [ c o l ] [ row ] = r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’ p l a y e r ’ ]
e l i f p i x e l == r e s o u r c e s . c o n s t a n t s . e d i t o r d e f [ ” r e d g h o s t ” ] :

57

19

20

21

22
23

24

l e v e l [ c o l ] [ row ] = r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’
red ghost ’ ]
e l i f p i x e l == r e s o u r c e s . c o n s t a n t s . e d i t o r d e f [ ” g r e e n g h o s t ”
]:
l e v e l [ c o l ] [ row ] = r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’
green ghost ’ ]
e l i f p i x e l == r e s o u r c e s . c o n s t a n t s . e d i t o r d e f [ ” b l u e g h o s t ” ] :
l e v e l [ c o l ] [ row ] = r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’
blue ghost ’ ]
return l e v e l

25

As seen, this code uses Pillow A.K.A. ’PIL’ Python module to process
bitmaps. Resources are also imported to utilize leveldef and editordef dictionaries. Input of the readlevel function is a path of a 32px x 32px bitmap,
the output is a 32 x 32 array of integers representing tile types at particular
positions on the board.

3.6.2

Checking wall type

As walls are displayed as different images (which is extensively described in
Section 2.3.1), following function is available to determine wall type.
1
2
3
4

5
6
7

8
9
10

11
12
13

14
15

def walltypecheck ( location ) :
r = t = l = b = 0
i f l o c a t i o n [ 0 ] != 0 :
i f l e v e l [ l o c a t i o n [ 0 ] − 1 ] [ l o c a t i o n [ 1 ] ] == r e s o u r c e s
l e v e l d e f [ ” wall ” ] :
l = 1
i f l o c a t i o n [ 0 ] != r e s o u r c e s . c o n s t a n t s . gamesize −1:
i f l e v e l [ l o c a t i o n [ 0 ] + 1 ] [ l o c a t i o n [ 1 ] ] == r e s o u r c e s
l e v e l d e f [ ” wall ” ] :
r = 1
i f l o c a t i o n [ 1 ] != 0 :
i f l e v e l [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] − 1 ] == r e s o u r c e s
l e v e l d e f [ ” wall ” ] :
t = 1
i f l o c a t i o n [ 1 ] != r e s o u r c e s . c o n s t a n t s . gamesize −1:
i f l e v e l [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] + 1 ] == r e s o u r c e s
l e v e l d e f [ ” wall ” ] :
b = 1
return str ( r ) + str ( t ) + str ( l ) + str (b)

. constants .

. constants .

. constants .

. constants .

16

Function walltypecheck takes an input of grid location in (x,y) format and
outputs a string of 0s and 1s corresponding with wall name (See Section
2.3.1 for wall names). Note usage of r,t,l,b variables which correspond with
this scheme:
separately.

58

Figure 3.5: Scheme showing which parts of wall are added according to
r,t,l,b values

3.6.3

Adding Sprites according to tile types

The following script is used to add Sprites to their respective groups. See
section 3.6.4 for reference.
1
2
3

4
5
6
7
8

9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

def loadlevel ( f i l e ) :
global level , coins total , player
# l e v e l −l o a d i n g p r o c e d u r e with i n p u t o f s t a n d a r d 32 x32 bitmap
level file
level = readlevel ( f i l e )
f o r c o l in range (0 , r e s o u r c e s . constants . gamesize ) :
f o r row i n r a n g e ( 0 , r e s o u r c e s . c o n s t a n t s . g a m e s i z e ) :
box = l e v e l [ c o l ] [ row ]
i f box != r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” w a l l ” ] and box !=
r e s o u r c e s . constants . l e v e l d e f [ ’ nothing ’ ] :
e a t a b l e = E a t a b l e ( 0 , ( c o l , row ) )
e a t a b l e s l i s t . add ( e a t a b l e )
c o i n s t o t a l += 1
i f box == r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” w a l l ” ] :
w a l l = Wall ( ( c o l , row ) , w a l l t y p e c h e c k ( ( c o l , row ) ) )
w a l l s l i s t . add ( w a l l )
e l i f box == r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” p l a y e r ” ] :
p l a y e r = P l a y e r ( ( c o l , row ) )
p l a y e r s l i s t . add ( p l a y e r )
e l i f box == r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” r e d g h o s t ” ] :
g h o s t = Ghost ( ( c o l , row ) , ’ r e d ’ )
g h o s t s l i s t . add ( g h o s t )
e l i f box == r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” b l u e g h o s t ” ] :
g h o s t = Ghost ( ( c o l , row ) , ’ b l u e ’ )
g h o s t s l i s t . add ( g h o s t )
e l i f box == r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” g r e e n g h o s t ” ] :
g h o s t = Ghost ( ( c o l , row ) , ’ g r e e n ’ )
g h o s t s l i s t . add ( g h o s t )

59

3.6.4

Sprite Groups

Within the main program file the following groups are globally declared.
1
2
3
4

e a t a b l e s l i s t = pygame . s p r i t e . Group ( )
w a l l s l i s t = pygame . s p r i t e . Group ( )
p l a y e r s l i s t = pygame . s p r i t e . Group ( )
g h o s t s l i s t = pygame . s p r i t e . Group ( )

Each of them stores Sprites of respective type - a very useful feature of
pygame.sprite allowing manipulating multiple objects at once.

3.7

Ghost pathfinding algorithm

This section covers the most algorithmically complex part of this project
- ghost pathfinding system. As seen in section 2.5.3 the concept is based
on BFS graph search. But first there must be a graph to begin with. It’s
important to note that the graph is stored in ’thegraph’ global variable pretty descriptive, as this is the only graph implementation used in this
project.

3.7.1

Graph structure

Formally - the graph is a list of lists of lists of lists of integers - notably complex structure. It’s easier to imagine it though as a two-dimensional matrix
of lists of tile locations - that sounds like something comprehensible by a
human mind. Namely - first two iterable arguments are (x,y) coordinates of
the tile we want to query for neighboring tiles. If we were to
1

p r i n t ( thegraph [ 5 ] [ 5 ] )

2

we would see a list of points in [x,y] format, all tiles that a Movable could
move to from tile (5,5).

3.7.2
1
2
3

4
5
6
7
8

9
10

Graph building

def graphbuilder () :
g l o b a l l e v e l , thegraph
thegraph = [ [ [ ] f o r i in range ( r e s o u r c e s . constants . gamesize ) ]
f o r j in range ( r e s o u r c e s . constants . gamesize ) ]
f o r i in range ( r e s o u r c e s . constants . gamesize ) :
f o r j in range ( r e s o u r c e s . constants . gamesize ) :
# i t e r a t i n g through a l l t i l e s i n t h e g r i d
i f l e v e l [ i ] [ j ] != r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” w a l l ” ] :
# t a k i n g advantage o f t h e f a c t t h a t Movables can move on
a l l t i l e s t h a t a r e not i n i t i a l l y marked a s w a l l s
location = [ i , j ]
# p r o c e s s i n g l o c a t i o n i n more s u i t a b l e format

60

11

12
13

14

15
16

17

18
19

20

21
22

23

# and now , i t e r a t i n g through a l l p o s s i b l e n e i g h b o u r s o f
t h e p r o c e s s e d t i l e ( with c h e c k i n g i f i t i s n ’ t by any chance a
border t i l e )
i f l o c a t i o n [ 0 ] != 0 :
i f l e v e l [ l o c a t i o n [ 0 ] − 1 ] [ l o c a t i o n [ 1 ] ] != r e s o u r c e s .
constants . l e v e l d e f [ ” wall ” ] :
t h e g r a p h [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] ] += [ [ l o c a t i o n [ 0 ]
− 1 , location [ 1 ] ] ]
i f l o c a t i o n [ 0 ] != r e s o u r c e s . c o n s t a n t s . gamesize −1:
i f l e v e l [ l o c a t i o n [ 0 ] + 1 ] [ l o c a t i o n [ 1 ] ] != r e s o u r c e s .
constants . l e v e l d e f [ ” wall ” ] :
t h e g r a p h [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] ] += [ [ l o c a t i o n [ 0 ]
+ 1 , location [ 1 ] ] ]
i f l o c a t i o n [ 1 ] != 0 :
i f l e v e l [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] − 1 ] != r e s o u r c e s .
constants . l e v e l d e f [ ” wall ” ] :
t h e g r a p h [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] ] += [ [ l o c a t i o n [ 0 ] ,
location [1] − 1]]
i f l o c a t i o n [ 1 ] != r e s o u r c e s . c o n s t a n t s . gamesize −1:
i f l e v e l [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] + 1 ] != r e s o u r c e s .
constants . l e v e l d e f [ ” wall ” ] :
t h e g r a p h [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] ] += [ [ l o c a t i o n [ 0 ] ,
location [1] + 1]]

24

As seen for every possible neighboring tile the algorithm checks whether it
is a wall and if it’s not - it adds it to the list of all tiles a Movable may move
to. As walls do not move, appear nor disappear this structure remains static
throughout the level and must only be processed once upon level loading.

3.7.3

Choosing a target tile for each ghost

As described in Section 3.5.1, resources.constants.scatterSize governs to how
distant tile should green and blue ghost move. But when we add let’s say
a vector (2,2) to player’s location, there is no guarantee that this tile is
not a wall. If it was a wall it wouldn’t appear on any list of neighbors of
surrounding tile - ghost wouldn’t be able to move there. Worse, there is no
guarantee that this tile is even within the boundaries of the game board.
I have discovered it during first tests of ghost chasing - game crashed as
internal algorithms tried to fetch neighbors of tile which coordinates were
greater than board size - this resulted in indexError. Therefore a need for
the following function appeared:
1
2
3
4
5
6
7
8
9

def f i n d n e a r e s t n o t w a l l ( point ) :
i f p o i n t [ 0 ] > r e s o u r c e s . c o n s t a n t s . gamesize −1:
p o i n t [ 0 ] = r e s o u r c e s . c o n s t a n t s . gamesize −1
i f point [ 0 ] < 0:
point [ 0 ] = 0
i f p o i n t [ 1 ] > r e s o u r c e s . c o n s t a n t s . gamesize −1:
p o i n t [ 1 ] = r e s o u r c e s . c o n s t a n t s . gamesize −1
i f point [ 1 ] < 0:
point [ 1 ] = 0

61

10

11
12
13
14
15
16
17
18
19
20
21

if

l e v e l [ p o i n t [ 0 ] ] [ p o i n t [ 1 ] ] != r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’
wall ’ ] :
return point
radius = 1
w h i l e True :
f o r i i n r a n g e ( p o i n t [0] − r a d i u s , p o i n t [ 0 ] + r a d i u s ) :
f o r j i n r a n g e ( p o i n t [1] − r a d i u s , p o i n t [ 1 ] + r a d i u s ) :
try :
i f l e v e l [ i ] [ j ] != r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’ w a l l ’ ] :
return [ i , j ]
except IndexError :
pass
r a d i u s += 1

22

With a slightly deceiving name - find nearest not wall - not only finds the
coordinates of the nearest tile that isn’t marked as a wall but it finds the
nearest tile that isn’t marked as a wall that actually exists. Within lines
2-9 the location is being confined within the boundaries of the board - then
condition in line 10 checks whether the tile in question is a wall - if it isn’t
- that solves the problem. Else - the actual search begins. With growing
radius neighboring tiles are checked for not being a wall. As this algorithm
may eventually lead to checking type of a tile outside the board, a try/catch
routine is used. By filtering cases of IndexError, nonexistent tiles aren’t
checked. I found this solution cleaner that limiting the borders of search,
checking whether radius doesn’t extend beyond the board, after all it’s only
3 very clean lines. The function eventually returns a nearest existing point
not being a wall.

3.7.4

Actual pathfinding

After giving it a thought, the ghosts don’t really require a complete path
to operate. They just need to know where next to move. One single tile
location or even a direction. I also figured that running searches from each
tile of ghost’s neighbors is inefficient. Out of pure reason... What seems
faster? Finding one needle in a haystack three times or finding one of three
needles in a haystack once? I would go for the second one. Here are two
diagrams illustrating the concept:

62

Figure 3.6: Inefficient method of running three searches.

63

Figure 3.7: Efficient method of running one search.
To keep things simple, my algorithm for pathfinding accepts three arguments: start (ghost position), end(target tile position) and forbidden (tile
the ghost moved from - ghost reversing prevention as per requirement 1h).
The code for the main pathfinding function is as follows:
1
2
3
4
5
6
7

8
9
10
11
12
13
14

d e f f i n d n e x t m o v e ( s t a r t , end , f o r b i d d e n ) :
visited = []
# s t o r i n g v i s i t e d nodes
queue = [ ]
# s t o r i n g nodes t o v i s i t
end = f i n d n e a r e s t n o t w a l l ( end )
# a s s t a r t i s g u a r a n t e e d not t o be w a l l , both ends a r e now
p l a c e s a Movable may move t o
n e i g h b o u r s = t h e g r a p h [ s t a r t [ 0 ] ] [ s t a r t [ 1 ] ] . copy ( )
# p r e v e n t i n g c o r r u p t i n g t h e g r a p h when e x c l u d i n g f o r b i d d e n t i l e
try :
# t r y a s f o r b i d d e n t i l e may be any t i l e a f t e r r e s e t
# p a r t i c u l a r l y i t may not be i n n e i g h b o r s
n e i g h b o u r s . remove ( [ f o r b i d d e n [ 0 ] , f o r b i d d e n [ 1 ] ] )
# removing f o r b i d d e n t i l e from n e i g h b o r s

64

15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

30
31

except Exception :
pass
queue . append ( [ end [ 0 ] , end [ 1 ] ] )
# s t a r t s e a r c h from t h e end ( t a r g e t t i l e )
v i s i t e d . append ( end )
# mark end a s a v i s i t e d node
f o r p o i n t i n queue :
i f p o i n t not i n v i s i t e d :
v i s i t e d . append ( p o i n t )
# mark c u r r e n t p o i n t a s v i s i t e d
i f point in neighbours :
return point
# i f s o l u t i o n i s f i n d r e t u r n next t i l e f o r t h e g h o s t
f o r node i n t h e g r a p h [ p o i n t [ 0 ] ] [ p o i n t [ 1 ] ] :
i f node not i n v i s i t e d and node != [ f o r b i d d e n [ 0 ] ,
forbidden [ 1 ] ] :
queue . append ( node )
# add a l l u n v i s i t e d n e i g h b o r s o f c u r r e n t node t o t h e
queue

32

Being a rather clean BFS implementation this code returns only the location
of one of ghost’s neighbors - the tile it has to move to next.

3.8

Designing resources

3.9

Core program code

3.9.1

Playing a single level

To initialize the game, the core program calls function playlevel(), which
takes no arguments as it utilizes global variables for reference on which level
should be played and on lives remaining.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

def playlevel () :
global coins eaten , coins total , lives , levelno
# marking v a r i a b l e s a s g l o b a l
coins total = coins eaten = 0
# re s e t t in g coin counters
p r e p a r e l e v e l ( r e s o u r c e s . paths . l e v e l o r d e r [ l e v e l n o ] )
# l e v e l loading
game on = True
# game s t a r t e r
c l o c k = pygame . time . Clock ( )
# clock i n i t
e a t a b l e s l i s t . update ( )
w a l l s l i s t . update ( )
p l a y e r s l i s t . update ( )
g h o s t s l i s t . update ( )
# u p d a t i n g S p r i t e Groups
player time segment = resources . constants .
playerTimeSegmentSize

65

18
19

g h o s t t i m e s e g m e n t = r e s o u r c e s . c o n s t a n t s . ghostTimeSegmentSize
# f o r c i n g p a t h f i n d i n g t o update

20

By this part all initialization is done and the program starts main game
loop.
1
2
3
4
5
6
7
8

9
10
11
12

# −−−−− Main game l o o p −−−−−
w h i l e game on :
# −−−−− L e v e l − winning h a n d l i n g −−−−−
i f c o i n s e a t e n == c o i n s t o t a l :
l e v e l n o += 1
game on = F a l s e
# −−−−− s t o p t h e l e v e l i f a l l c o i n s a r e e a t e n −−−−−
i f p l a y e r t i m e s e g m e n t == r e s o u r c e s . c o n s t a n t s .
playerTimeSegmentSize :
# −−−−− Handling u s e r i n p u t pt1 −−−−−−
f o r e v e n t i n pygame . e v e n t . g e t ( ) :
i f e v e n t . type == pygame . QUIT :
game on = F a l s e

13
14
15
16
17
18
19

20
21
22
23

24
25
26
27
28
29
30
31
32
33

# −−−−− c h e c k i n g p r e s s e d k e y s −−−−−
k e y s = pygame . key . g e t p r e s s e d ( )
# −−−−− w a l l c o l l i s i o n check −−−−−
surroundings = walltypecheck ( player . location )
# −−−−− g h o s t movement h a n d l i n g pt 1 −−−−−
i f g h o s t t i m e s e g m e n t == r e s o u r c e s . c o n s t a n t s .
ghostTimeSegmentSize :
# i f i t ’ s time t o update p a t h s update them
f o r ghost in g h o s t s l i s t . s p r i t e s () :
i f g h o s t . c o l o r == ’ r e d ’ :
ghost . n e x t t i l e = find next move ( ghost . location , player
. location , ghost . p r e v i o u s l o c a t i o n )
e l i f g h o s t . c o l o r == ’ b l u e ’ :
ghost . n e x t t i l e = find next move ( ghost . location ,
[ player . location [ 0 ] + resources . constants . scatterSize ,
player . location [ 1 ] + resources . constants . scatterSize ] ,
ghost . p r e v i o u s l o c a t i o n )
e l i f g h o s t . c o l o r == ’ g r e e n ’ :
ghost . n e x t t i l e = find next move ( ghost . location ,
[ player . location [ 0 ] − resources . constants . scatterSize ,
player . location [ 1 ] − resources . constants . scatterSize ] ,
ghost . p r e v i o u s l o c a t i o n )

34
35
36

37

# −−−−− h a n d l i n g some f r a m e s /move −−−−−
p l a y e r p a r t = r e s o u r c e s . co nst ant s . playerTimeSegmentSize −
player time segment
g h o s t p a r t = r e s o u r c e s . c o n s t a n t s . ghostTimeSegmentSize −
ghost time segment

38
39
40
41
42

# −−−−− i n p u t h a n d l i n g pt 2 / p l a y e r movement h a n d l i n g −−−−−
i f k e y s [ pygame . K LEFT ] and s u r r o u n d i n g s [ 2 ] == ’ 0 ’ :
p l a y e r . move ( ’ l e f t ’ , p l a y e r p a r t )
e l i f k e y s [ pygame . K RIGHT ] and s u r r o u n d i n g s [ 0 ] == ’ 0 ’ :

66

43
44
45
46
47

p l a y e r . move ( ’ r i g h t ’ , p l a y e r p a r t )
e l i f k e y s [ pygame . K UP ] and s u r r o u n d i n g s [ 1 ] == ’ 0 ’ :
p l a y e r . move ( ’ up ’ , p l a y e r p a r t )
e l i f k e y s [ pygame .K DOWN] and s u r r o u n d i n g s [ 3 ] == ’ 0 ’ :
p l a y e r . move ( ’ down ’ , p l a y e r p a r t )

48
49
50
51
52

53
54

55
56
57
58
59
60
61
62
63

64

65
66
67
68

# −−−−− g h o s t movement h a n d l i n g pt 2 −−−−−
f o r ghost in g h o s t s l i s t . s p r i t e s () :
try :
g h o s t . move ( ( g h o s t . n e x t t i l e [ 0 ] − g h o s t . l o c a t i o n [ 0 ] , −
ghost . n e x t t i l e [ 1 ] + ghost . l o c a t i o n [ 1 ] ) , ghost part )
except Exception :
# i f f o r some u n f o r s e e n r e a s o n i t ’ s i m p o s s i b l e t o move
the ghost j u s t l e a v e i t there
pass
# −−−−− p l a y e r dying h a n d l i n g −−−−−
f o r ghost in g h o s t s l i s t . s p r i t e s () :
i f g h o s t . l o c a t i o n == p l a y e r . l o c a t i o n :
# decrease l i v e s counter
l i v e s −= 1
reset ()
# r e s e t t h e board
player time segment = resources . constants .
p l a y e r T i m e S e g m e n t S i z e+1
ghost time segment = resources . constants .
ghostTimeSegmentSize+1
# f o r c e game t o update g h o s t p a t h s a f t e r r e s p a w n i n g
i f l i v e s <= 0 :
# i f t h e p l a y e r i s dead f o r good
break

69
70
71
72
73
74
75
76
77
78
79
80
81

# −−−−− Updating s p r i t e s p o s i t i o n −−−−−
e a t a b l e s l i s t . update ( )
w a l l s l i s t . update ( )
p l a y e r s l i s t . update ( )
g h o s t s l i s t . update ( )
# −−−−− F i l l s c r e e n with background −−−−−
s c r e e n . f i l l ( r e s o u r c e s . c o l o r s . background )
# −−−−− . . . and s p r i t e s −−−−−
e a t a b l e s l i s t . draw ( s c r e e n )
w a l l s l i s t . draw ( s c r e e n )
p l a y e r s l i s t . draw ( s c r e e n )
g h o s t s l i s t . draw ( s c r e e n )

82
83
84

85
86
87

# −−−−− Counter i n f o −−−−−
l a b e l = myfont . r e n d e r ( ” Coins e a t e n ” + s t r ( c o i n s e a t e n ) +” /
” + str ( coins total ) +
”
Lives remaining ” + s t r ( l i v e s ) +
”
L e v e l ” + s t r ( l e v e l n o +1) , 1 , ( 2 5 5 , 2 5 5 , 0 ) )
screen . b l i t ( label , ( resources . constants . tileWidth / 2 ,
r e s o u r c e s . constants . gamesize ∗ r e s o u r c e s . constants . tileWidth )
)

88
89

# −−−−− R e f r e s h S c r e e n −−−−−

67

90

pygame . d i s p l a y . f l i p ( )

91
92
93
94
95

# −−−−− FPS h a n d l i n g −−−−−
p l a y e r t i m e s e g m e n t −= 1
g h o s t t i m e s e g m e n t −= 1
clock . tick ( resources . constants . fps )

96
97
98
99
100
101
102

# −−−−− e a t i n g h a n d l i n g −−−−−
for eatable in e a t a b l e s l i s t . s p r i t e s () :
i f e a t a b l e . l o c a t i o n == p l a y e r . l o c a t i o n :
eatable . k i l l ()
c o i n s e a t e n += 1
# i n c r e a s i n g eaten points counter

103
104
105
106

107
108

# −−−−− i n i t i a l i z i n g new time p e r i o d s −−−−−
i f not p l a y e r t i m e s e g m e n t :
player time segment = resources . constants .
playerTimeSegmentSize
i f not g h o s t t i m e s e g m e n t :
ghost time segment = resources . constants .
ghostTimeSegmentSize

109

Development of this piece of code was particularly difficult due to having to
simultaneously implement two Time Segment handlers. (See Section 2.5.1
for Time Segment explanation.) My first approach was to implement those
within single counter. It worked but there was no way to satisfy Requirement 2f. Another problem I encountered was with the input handling. The
player’s sprite was jumping around, because player could change moving direction mid-time segment. The obvious choice was to move keypress checking to section that only executes once per time segment, rather than once
per frame. My concern was that this will affect overall user input performance, compromising Requirement 3a. My preliminary testing as well as
β-testing revealed that with 60fps and player segment size equal to 10, the
input rate of 6 key presses per second seemed optimal.

3.9.2

Function switching levels

Function named main() taking no parameters, iterating through levels and
displaying appropriate messages. This is the main function that launches
the whole game.
1
2
3

4
5
6
7
8

d e f main ( ) :
show message ( r e s o u r c e s . c o n s t a n t s . t u t o r i a l S t r i n g L i s t )
w h i l e l i v e s > 0 and l e v e l n o <= r e s o u r c e s . c o n s t a n t s . t o t a l l e v e l s
:
print ( levelno )
playlevel ()
show message ( r e s o u r c e s . c o n s t a n t s . c o n g r a t s S t r i n g L i s t )
i f lives > 0:
show message ( r e s o u r c e s . c o n s t a n t s . r e a l C o n g r a t s S t r i n g L i s t )

68

9
10

else :
show message ( r e s o u r c e s . c o n s t a n t s . t h e E n d S t r i n g L i s t )

11

3.9.3

Displaying messages

As it’s seen in the Section 3.9.2 - the function show message is used to
display small text messages on the screen. Those messages include:
• Tutorial screen
• Congratulations on completing a level
• A Game Over screen saying that the player lost
• Congratulations on completing the whole game
TODO: Add this function code after ’press [space] to continue’ is implemented.

69

Chapter 4

Code appendix
TODO: update these files after changes

4.1
1
2
3
4
5
6
7
8
9
10
11
12

13
14

main.py

from c l a s s e s import ∗
import r e s o u r c e s
from l e v e l p r o c e s s e r import r e a d l e v e l
from time import s l e e p
p l a y e r = None
coins total = 0
coins eaten = 0
l e v e l = None
levelno = 0
l i v e s = 30
pygame . i n i t ( )
myfont = pygame . f o n t . SysFont ( ” monospace ” , r e s o u r c e s . c o n s t a n t s .
fontsize )
pygame . d i s p l a y . s e t c a p t i o n ( ”PycMan by Jan D z i e d z i c ( 1 3MF2) ” )
s c r e e n = pygame . d i s p l a y . set mo de ( r e s o u r c e s . c o n s t a n t s . windowSize )

15
16

17

# −−−−− This 2D a r r a y h o l d s i n f o on l o c a t i o n l i s t s a c c e s s i b l e (
common edge ) from t i l e r e p r e s e n t e d by a d d r e s s −−−−−
thegraph = [ [ [ ] f o r i in range ( r e s o u r c e s . constants . gamesize ) ]
f o r j in range ( r e s o u r c e s . constants . gamesize ) ]

18
19
20
21
22
23

24
25
26

27

def walltypecheck ( location ) :
r = t = l = b = 0
i f l o c a t i o n [ 0 ] != 0 :
i f l e v e l [ l o c a t i o n [ 0 ] − 1 ] [ l o c a t i o n [ 1 ] ] == r e s o u r c e s . c o n s t a n t s .
l e v e l d e f [ ” wall ” ] :
l = 1
i f l o c a t i o n [ 0 ] != r e s o u r c e s . c o n s t a n t s . gamesize −1:
i f l e v e l [ l o c a t i o n [ 0 ] + 1 ] [ l o c a t i o n [ 1 ] ] == r e s o u r c e s . c o n s t a n t s .
l e v e l d e f [ ” wall ” ] :
r = 1

70

28
29

30
31
32

33
34

i f l o c a t i o n [ 1 ] != 0 :
i f l e v e l [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] − 1 ] == r e s o u r c e s . c o n s t a n t s .
l e v e l d e f [ ” wall ” ] :
t = 1
i f l o c a t i o n [ 1 ] != r e s o u r c e s . c o n s t a n t s . gamesize −1:
i f l e v e l [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] + 1 ] == r e s o u r c e s . c o n s t a n t s .
l e v e l d e f [ ” wall ” ] :
b = 1
return str ( r ) + str ( t ) + str ( l ) + str (b)

35
36
37

# −−−−− Graphing s t u f f ( f o r p a t h f i n d i n g ) −−−−−

38
39
40
41
42

43
44
45
46
47

48
49

50
51

52

53
54

55

56
57

58

59
60

61

def graphbuilder () :
g l o b a l l e v e l , thegraph
thegraph = [ [ [ ] f o r i in range ( r e s o u r c e s . constants . gamesize ) ]
f o r j in range ( r e s o u r c e s . constants . gamesize ) ]
f o r i in range ( r e s o u r c e s . constants . gamesize ) :
f o r j in range ( r e s o u r c e s . constants . gamesize ) :
# i t e r a t i n g through a l l t i l e s i n t h e g r i d
i f l e v e l [ i ] [ j ] != r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” w a l l ” ] :
# t a k i n g advantage o f t h e f a c t t h a t Movables can move on
a l l t i l e s t h a t a r e not i n i t i a l l y marked a s w a l l s
location = [ i , j ]
# and now , i t e r a t i n g through a l l p o s s i b l e n e i g h b o u r s o f
t h e p r o c e s s e d t i l e ( with c h e c k i n g i f i t i s n ’ t by any chance a
border t i l e )
i f l o c a t i o n [ 0 ] != 0 :
i f l e v e l [ l o c a t i o n [ 0 ] − 1 ] [ l o c a t i o n [ 1 ] ] != r e s o u r c e s .
constants . l e v e l d e f [ ” wall ” ] :
t h e g r a p h [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] ] += [ [ l o c a t i o n [ 0 ]
− 1 , location [ 1 ] ] ]
i f l o c a t i o n [ 0 ] != r e s o u r c e s . c o n s t a n t s . gamesize −1:
i f l e v e l [ l o c a t i o n [ 0 ] + 1 ] [ l o c a t i o n [ 1 ] ] != r e s o u r c e s .
constants . l e v e l d e f [ ” wall ” ] :
t h e g r a p h [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] ] += [ [ l o c a t i o n [ 0 ]
+ 1 , location [ 1 ] ] ]
i f l o c a t i o n [ 1 ] != 0 :
i f l e v e l [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] − 1 ] != r e s o u r c e s .
constants . l e v e l d e f [ ” wall ” ] :
t h e g r a p h [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] ] += [ [ l o c a t i o n [ 0 ] ,
location [1] − 1]]
i f l o c a t i o n [ 1 ] != r e s o u r c e s . c o n s t a n t s . gamesize −1:
i f l e v e l [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] + 1 ] != r e s o u r c e s .
constants . l e v e l d e f [ ” wall ” ] :
t h e g r a p h [ l o c a t i o n [ 0 ] ] [ l o c a t i o n [ 1 ] ] += [ [ l o c a t i o n [ 0 ] ,
location [1] + 1]]

62
63
64
65
66
67

def f i n d n e a r e s t n o t w a l l ( point ) :
i f p o i n t [ 0 ] > r e s o u r c e s . c o n s t a n t s . gamesize −1:
p o i n t [ 0 ] = r e s o u r c e s . c o n s t a n t s . gamesize −1
i f point [ 0 ] < 0:

71

68
69
70
71
72
73
74

75
76
77
78
79
80

81
82
83
84

point [ 0 ] = 0
i f p o i n t [ 1 ] > r e s o u r c e s . c o n s t a n t s . gamesize −1:
p o i n t [ 1 ] = r e s o u r c e s . c o n s t a n t s . gamesize −1
i f point [ 1 ] < 0:
point [ 1 ] = 0
radius = 1
i f l e v e l [ p o i n t [ 0 ] ] [ p o i n t [ 1 ] ] != r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’
wall ’ ] :
return point
w h i l e True :
f o r i i n r a n g e ( p o i n t [0] − r a d i u s , p o i n t [ 0 ] + r a d i u s ) :
f o r j i n r a n g e ( p o i n t [1] − r a d i u s , p o i n t [ 1 ] + r a d i u s ) :
try :
i f l e v e l [ i ] [ j ] != r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’ w a l l ’
]:
return [ i , j ]
except IndexError :
pass
r a d i u s += 1

85
86
87
88
89
90
91
92
93

94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115

116

d e f f i n d n e x t m o v e ( s t a r t , end , f o r b i d d e n ) :
visited = []
# s t o r i n g v i s i t e d nodes
queue = [ ]
# s t o r i n g nodes t o v i s i t
end = f i n d n e a r e s t n o t w a l l ( end )
# a s s t a r t i s g u a r a n t e e d not t o be w a l l , both ends a r e now
p l a c e s a Movable may move t o
n e i g h b o u r s = t h e g r a p h [ s t a r t [ 0 ] ] [ s t a r t [ 1 ] ] . copy ( )
# p r e v e n t i n g c o r r u p t i n g t h e g r a p h when e x c l u d i n g f o r b i d d e n t i l e
try :
# t r y a s f o r b i d d e n t i l e may be any t i l e a f t e r r e s e t
# p a r t i c u l a r l y i t may not be i n n e i g h b o r s
n e i g h b o u r s . remove ( [ f o r b i d d e n [ 0 ] , f o r b i d d e n [ 1 ] ] )
# removing f o r b i d d e n t i l e from n e i g h b o r s
except Exception :
pass
queue . append ( [ end [ 0 ] , end [ 1 ] ] )
# s t a r t s e a r c h from t h e end ( t a r g e t t i l e )
v i s i t e d . append ( end )
# mark end a s a v i s i t e d node
f o r p o i n t i n queue :
i f p o i n t not i n v i s i t e d :
v i s i t e d . append ( p o i n t )
# mark c u r r e n t p o i n t a s v i s i t e d
i f point in neighbours :
return point
# i f s o l u t i o n i s f i n d r e t u r n next t i l e f o r t h e g h o s t
f o r node i n t h e g r a p h [ p o i n t [ 0 ] ] [ p o i n t [ 1 ] ] :
i f node not i n v i s i t e d and node != [ f o r b i d d e n [ 0 ] ,
forbidden [ 1 ] ] :
queue . append ( node )

72

117

# add a l l u n v i s i t e d n e i g h b o r s o f c u r r e n t node t o t h e
queue

118
119
120

# −−−−− −−−−− −−−−−

121
122
123
124
125

126
127
128
129
130

131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148

def loadlevel ( f i l e ) :
global level , coins total , player
# l e v e l −l o a d i n g p r o c e d u r e with i n p u t o f s t a n d a r d 32 x32 bitmap
level file
level = readlevel ( f i l e )
f o r c o l in range (0 , r e s o u r c e s . constants . gamesize ) :
f o r row i n r a n g e ( 0 , r e s o u r c e s . c o n s t a n t s . g a m e s i z e ) :
box = l e v e l [ c o l ] [ row ]
i f box != r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” w a l l ” ] and box !=
r e s o u r c e s . constants . l e v e l d e f [ ’ nothing ’ ] :
e a t a b l e = E a t a b l e ( ’ c o i n ’ , ( c o l , row ) )
e a t a b l e s l i s t . add ( e a t a b l e )
c o i n s t o t a l += 1
i f box == r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” w a l l ” ] :
w a l l = Wall ( ( c o l , row ) , w a l l t y p e c h e c k ( ( c o l , row ) ) )
w a l l s l i s t . add ( w a l l )
e l i f box == r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” p l a y e r ” ] :
p l a y e r = P l a y e r ( ( c o l , row ) )
p l a y e r s l i s t . add ( p l a y e r )
e l i f box == r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” r e d g h o s t ” ] :
r e d g h o s t = Ghost ( ( c o l , row ) , ’ r e d ’ )
g h o s t s l i s t . add ( r e d g h o s t )
e l i f box == r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” b l u e g h o s t ” ] :
r e d g h o s t = Ghost ( ( c o l , row ) , ’ b l u e ’ )
g h o s t s l i s t . add ( r e d g h o s t )
e l i f box == r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ” g r e e n g h o s t ” ] :
r e d g h o s t = Ghost ( ( c o l , row ) , ’ g r e e n ’ )
g h o s t s l i s t . add ( r e d g h o s t )

149
150
151
152
153
154

e a t a b l e s l i s t = pygame . s p r i t e . Group ( )
w a l l s l i s t = pygame . s p r i t e . Group ( )
p l a y e r s l i s t = pygame . s p r i t e . Group ( )
g h o s t s l i s t = pygame . s p r i t e . Group ( )

155
156
157
158

159
160
161
162
163
164

def prepare level ( l e v e l f i l e ) :
global eatables list , walls list , players list , ghosts list ,
player
e a t a b l e s l i s t = pygame . s p r i t e . Group ( )
w a l l s l i s t = pygame . s p r i t e . Group ( )
p l a y e r s l i s t = pygame . s p r i t e . Group ( )
g h o s t s l i s t = pygame . s p r i t e . Group ( )
loadlevel ( l e v e l f i l e )
graphbuilder ()

165
166

73

167
168
169
170
171
172
173

d e f show message ( messageboard ) :
s c r e e n . f i l l ( r e s o u r c e s . c o l o r s . background )
f o r i i n r a n g e ( l e n ( messageboard ) ) :
l a b e l = myfont . r e n d e r ( messageboard [ i ] , 1 , ( 2 5 5 , 2 5 5 , 0 ) )
screen . b l i t ( label , (0 , resources . constants . f o n t s i z e ∗ i ) )
pygame . d i s p l a y . f l i p ( )
sleep (5)

174
175
176
177

def show tutorial () :
show message ( r e s o u r c e s . c o n s t a n t s . t u t o r i a l S t r i n g L i s t )

178
179
180
181
182
183

184
185
186

def show congrats () :
s c r e e n . f i l l ( r e s o u r c e s . c o l o r s . background )
f o r i in range ( len ( r e s o u r c e s . constants . c o n g r a t s S t r i n g L i s t ) ) :
l a b e l = myfont . r e n d e r ( r e s o u r c e s . c o n s t a n t s . c o n g r a t s S t r i n g L i s t
[ i ] , 1 , (255 , 255 , 0) )
screen . b l i t ( label , (0 , resources . constants . f o n t s i z e ∗ i ) )
pygame . d i s p l a y . f l i p ( )
sleep (5)

187
188
189
190
191

192

193
194
195

def show real congrats () :
s c r e e n . f i l l ( r e s o u r c e s . c o l o r s . background )
f o r i in range ( len ( r e s o u r c e s . constants . r e a l C o n g r a t s S t r i n g L i s t )
):
l a b e l = myfont . r e n d e r ( r e s o u r c e s . c o n s t a n t s .
r e a l C o n g r a t s S t r i n g L i s t [ i ] , 1 , (255 , 255 , 0) )
screen . b l i t ( label , (0 , resources . constants . f o n t s i z e ∗ i ) )
pygame . d i s p l a y . f l i p ( )
sleep (5)

196
197
198
199
200

201
202
203

d e f show permanent death ( ) :
s c r e e n . f i l l ( r e s o u r c e s . c o l o r s . background )
f o r i in range ( len ( r e s o u r c e s . constants . theEndStringList ) ) :
l a b e l = myfont . r e n d e r ( r e s o u r c e s . c o n s t a n t s . t h e E n d S t r i n g L i s t [ i
] , 1 , (255 , 255 , 0) )
screen . b l i t ( label , (0 , resources . constants . f o n t s i z e ∗ i ) )
pygame . d i s p l a y . f l i p ( )
sleep (5)

204
205
206
207
208
209

def reset () :
f o r ghost in g h o s t s l i s t . s p r i t e s () :
ghost . r e s e t ()
player . reset ()

210
211
212
213
214
215
216

def playlevel () :
global coins eaten , coins total , lives , levelno , screen
# marking v a r i a b l e s a s g l o b a l
coins total = coins eaten = 0
# re s e t t in g coin counters

74

217
218
219
220
221
222
223
224
225
226
227
228

229
230
231
232
233
234
235
236
237
238

239
240
241
242
243
244
245
246
247
248
249

250
251
252
253

254
255
256

257

258
259
260
261

262

p r e p a r e l e v e l ( r e s o u r c e s . paths . l e v e l o r d e r [ l e v e l n o ] )
# l e v e l loading
game on = True
# game s t a r t e r
c l o c k = pygame . time . Clock ( )
# clock i n i t
e a t a b l e s l i s t . update ( )
w a l l s l i s t . update ( )
p l a y e r s l i s t . update ( )
g h o s t s l i s t . update ( )
# u p d a t i n g S p r i t e Groups
player time segment = resources . constants .
playerTimeSegmentSize
g h o s t t i m e s e g m e n t = r e s o u r c e s . c o n s t a n t s . ghostTimeSegmentSize
# f o r c i n g p a t h f i n d i n g t o update
# −−−−− Main game l o o p −−−−−
w h i l e game on :
# −−−−− L e v e l − winning h a n d l i n g −−−−−
i f c o i n s e a t e n == c o i n s t o t a l :
l e v e l n o += 1
game on = F a l s e
# −−−−− s t o p t h e l e v e l i f a l l c o i n s a r e e a t e n −−−−−
i f p l a y e r t i m e s e g m e n t == r e s o u r c e s . c o n s t a n t s .
playerTimeSegmentSize :
# −−−−− Handling u s e r i n p u t pt1 −−−−−−
f o r e v e n t i n pygame . e v e n t . g e t ( ) :
i f e v e n t . type == pygame . QUIT :
game on = F a l s e
exit (0)
# −−−−− c h e c k i n g p r e s s e d k e y s −−−−−
k e y s = pygame . key . g e t p r e s s e d ( )
# −−−−− w a l l c o l l i s i o n check −−−−−
surroundings = walltypecheck ( player . location )
# −−−−− g h o s t movement h a n d l i n g pt 1 −−−−−
i f g h o s t t i m e s e g m e n t == r e s o u r c e s . c o n s t a n t s .
ghostTimeSegmentSize :
# i f i t ’ s time t o update p a t h s update them
f o r ghost in g h o s t s l i s t . s p r i t e s () :
i f g h o s t . c o l o r == ’ r e d ’ :
ghost . n e x t t i l e = find next move ( ghost . location , player
. location , ghost . p r e v i o u s l o c a t i o n )
e l i f g h o s t . c o l o r == ’ b l u e ’ :
ghost . n e x t t i l e = find next move ( ghost . location ,
[ player . location [ 0 ] + resources .
constants . scatterSize ,
player . location [ 1 ] + resources .
constants . scatterSize ] ,
ghost . p r e v i o u s l o c a t i o n )
e l i f g h o s t . c o l o r == ’ g r e e n ’ :
ghost . n e x t t i l e = find next move ( ghost . location ,
[ player . location [ 0 ] − resources .
constants . scatterSize ,
player . location [ 1 ] − resources .
constants . scatterSize ] ,

75

263

ghost . p r e v i o u s l o c a t i o n )

264
265
266

267

# −−−−− h a n d l i n g some f r a m e s /move −−−−−
p l a y e r p a r t = r e s o u r c e s . co nst ant s . playerTimeSegmentSize −
player time segment
g h o s t p a r t = r e s o u r c e s . c o n s t a n t s . ghostTimeSegmentSize −
ghost time segment

268
269
270
271
272
273
274
275
276
277

# −−−−− i n p u t h a n d l i n g pt 2 / p l a y e r movement h a n d l i n g −−−−−
i f k e y s [ pygame . K LEFT ] and s u r r o u n d i n g s [ 2 ] == ’ 0 ’ :
p l a y e r . move ( ’ l e f t ’ , p l a y e r p a r t )
e l i f k e y s [ pygame . K RIGHT ] and s u r r o u n d i n g s [ 0 ] == ’ 0 ’ :
p l a y e r . move ( ’ r i g h t ’ , p l a y e r p a r t )
e l i f k e y s [ pygame . K UP ] and s u r r o u n d i n g s [ 1 ] == ’ 0 ’ :
p l a y e r . move ( ’ up ’ , p l a y e r p a r t )
e l i f k e y s [ pygame .K DOWN] and s u r r o u n d i n g s [ 3 ] == ’ 0 ’ :
p l a y e r . move ( ’ down ’ , p l a y e r p a r t )

278
279
280
281
282

283
284

285
286
287
288
289
290
291
292
293

294

295
296
297
298

# −−−−− g h o s t movement h a n d l i n g pt 2 −−−−−
f o r ghost in g h o s t s l i s t . s p r i t e s () :
try :
g h o s t . move ( ( g h o s t . n e x t t i l e [ 0 ] − g h o s t . l o c a t i o n [ 0 ] , −
ghost . n e x t t i l e [ 1 ] + ghost . l o c a t i o n [ 1 ] ) , ghost part )
except Exception :
# i f f o r some u n f o r s e e n r e a s o n i t ’ s i m p o s s i b l e t o move
the ghost j u s t l e a v e i t there
pass
# −−−−− p l a y e r dying h a n d l i n g −−−−−
f o r ghost in g h o s t s l i s t . s p r i t e s () :
i f g h o s t . l o c a t i o n == p l a y e r . l o c a t i o n :
# decrease l i v e s counter
l i v e s −= 1
reset ()
# r e s e t t h e board
player time segment = resources . constants .
p l a y e r T i m e S e g m e n t S i z e+1
ghost time segment = resources . constants .
ghostTimeSegmentSize+1
# f o r c e game t o update g h o s t p a t h s a f t e r r e s p a w n i n g
i f l i v e s <= 0 :
# i f t h e p l a y e r i s dead f o r good
break

299
300
301
302
303
304
305
306
307
308
309
310

# −−−−− Updating s p r i t e s p o s i t i o n −−−−−
e a t a b l e s l i s t . update ( )
w a l l s l i s t . update ( )
p l a y e r s l i s t . update ( )
g h o s t s l i s t . update ( )
# −−−−− F i l l s c r e e n with background −−−−−
s c r e e n . f i l l ( r e s o u r c e s . c o l o r s . background )
# −−−−− . . . and s p r i t e s −−−−−
e a t a b l e s l i s t . draw ( s c r e e n )
w a l l s l i s t . draw ( s c r e e n )
p l a y e r s l i s t . draw ( s c r e e n )

76

g h o s t s l i s t . draw ( s c r e e n )

311
312

# −−−−− Counter i n f o −−−−−
l a b e l = myfont . r e n d e r ( ” Coins e a t e n ” + s t r ( c o i n s e a t e n ) +” /
” + str ( coins total ) +
” Lives remaining ” + s t r ( l i v e s ) +
” L e v e l ” + s t r ( l e v e l n o +1) , 1 , ( 2 5 5 , 2 5 5 , 0 ) )
screen . b l i t ( label , ( resources . constants . tileWidth / 2 ,
r e s o u r c e s . constants . gamesize ∗ r e s o u r c e s . constants . tileWidth )
)

313
314

315
316
317

318

# −−−−− R e f r e s h S c r e e n −−−−−
pygame . d i s p l a y . f l i p ( )

319
320
321

# −−−−− FPS h a n d l i n g −−−−−
p l a y e r t i m e s e g m e n t −= 1
g h o s t t i m e s e g m e n t −= 1
clock . tick ( resources . constants . fps )

322
323
324
325
326

# −−−−− e a t i n g h a n d l i n g −−−−−
for eatable in e a t a b l e s l i s t . s p r i t e s () :
i f e a t a b l e . l o c a t i o n == p l a y e r . l o c a t i o n :
eatable . k i l l ()
c o i n s e a t e n += 1
# i n c r e a s i n g eaten points counter

327
328
329
330
331
332
333

# −−−−− i n i t i a l i z i n g new time p e r i o d s −−−−−
i f not p l a y e r t i m e s e g m e n t :
player time segment = resources . constants .
playerTimeSegmentSize
i f not g h o s t t i m e s e g m e n t :
ghost time segment = resources . constants .
ghostTimeSegmentSize

334
335
336

337
338

339
340
341
342
343

344
345
346
347
348
349
350

d e f main ( ) :
show message ( r e s o u r c e s . c o n s t a n t s . t u t o r i a l S t r i n g L i s t )
w h i l e l i v e s > 0 and l e v e l n o <= r e s o u r c e s . c o n s t a n t s . t o t a l l e v e l s
:
print ( levelno )
playlevel ()
show message ( r e s o u r c e s . c o n s t a n t s . c o n g r a t s S t r i n g L i s t )
i f lives > 0:
show message ( r e s o u r c e s . c o n s t a n t s . r e a l C o n g r a t s S t r i n g L i s t )
else :
show message ( r e s o u r c e s . c o n s t a n t s . t h e E n d S t r i n g L i s t )

351
352

main ( )

353

4.2
1

classes.py

import pygame

77

2

import r e s o u r c e s

3
4
5
6
7
8
9
10
11

c l a s s GameObject ( pygame . s p r i t e . S p r i t e ) :
def
i n i t ( self , location ) :
super () .
init
()
s e l f . image = None
s e l f . location = location
s e l f . initiallocation = location
s e l f . r e c t = None

12
13

14
15
16
17
18

d e f s e t i m a g e ( s e l f , image , s i z e=r e s o u r c e s . c o n s t a n t s . t i l e S i z e ,
r o t a t i o n =0) :
s e l f . image = pygame . image . l o a d ( r e s o u r c e s . p a t h s . image [ image ] )
s e l f . image = pygame . t r a n s f o r m . s c a l e ( s e l f . image , s i z e )
s e l f . image = pygame . t r a n s f o r m . r o t a t e ( s e l f . image , r o t a t i o n )
s e l f . r e c t = s e l f . image . g e t r e c t ( )
s e l f . rect .x , s e l f . rect . y = s e l f . location [0 ] ∗ resources .
constants . tileWidth , s e l f . l o c a t i o n [ 1 ] ∗ r e s o u r c e s . constants .
tileWidth

19
20
21
22
23
24
25
26
27
28

c l a s s E a t a b l e ( GameObject ) :
def
i n i t ( s e l f , type , l o c a t i o n ) :
super () .
i n i t ( location )
s e l f . type = type
i f type == ” c o i n ” :
s e l f . setimage ( ” coin ” , resources . constants . e a t a b l e S i z e )
e l i f type == ” h e a r t ” :
s e l f . setimage ( ” heart ” , resources . constants . e a t a b l e S i z e )

29
30
31
32
33
34

c l a s s Wall ( GameObject ) :
def
i n i t ( s e l f , l o c a t i o n , type ) :
super () .
i n i t ( location )
s e l f . s e t i m a g e ( ’w ’+s t r ( type ) )

35
36
37
38
39
40
41

c l a s s Movable ( GameObject ) :
def
i n i t ( self , location ) :
super () .
i n i t ( location )
s e l f . image = None
s e l f . speed = (0 , 0)

42
43

44

d e f s e t i m a g e ( s e l f , image , s i z e=r e s o u r c e s . c o n s t a n t s . movableSize
, r o t a t i o n =0) :
s u p e r ( ) . s e t i m a g e ( image , s i z e , r o t a t i o n )

45
46

47
48
49
50

d e f move ( s e l f , d i r e c t i o n , s e g m e n t s i z e , p a r t=r e s o u r c e s .
co nst ant s . playerTimeSegmentSize − 1) :
i f d i r e c t i o n == ’ up ’ o r d i r e c t i o n == ( 0 , 1 ) :
s e l f . s p e e d = ( 0 , −1)
e l i f d i r e c t i o n == ’ down ’ o r d i r e c t i o n == ( 0 , −1) :
s e l f . speed = (0 , 1)

78

51
52
53
54
55
56

57

58
59

60

e l i f d i r e c t i o n == ’ l e f t ’ o r d i r e c t i o n == ( −1 , 0 ) :
s e l f . s p e e d = ( −1 , 0 )
e l i f d i r e c t i o n == ’ r i g h t ’ o r d i r e c t i o n == ( 1 , 0 ) :
s e l f . speed = (1 , 0)
p a r t 2 = ( p a r t +1) / s e g m e n t s i z e
s e l f . r e c t . x , s e l f . r e c t . y = ( s e l f . l o c a t i o n [ 0 ] + s e l f . speed [ 0 ]
∗ r e s o u r c e s . constants . speedFactor ∗ part2 ) ∗ r e s o u r c e s .
constants . tileWidth ,\
( s e l f . l o c a t i o n [ 1 ] + s e l f . speed [ 1 ] ∗ r e s o u r c e s
. constants . speedFactor ∗ part2 ) ∗ r e s o u r c e s . constants .
tileWidth
i f p a r t == s e g m e n t s i z e − 1 :
s e l f . l o c a t i o n = s e l f . l o c a t i o n [ 0 ] + s e l f . speed [ 0 ] ∗
r e s o u r c e s . constants . speedFactor , \
s e l f . l o c a t i o n [ 1 ] + s e l f . speed [ 1 ] ∗ r e s o u r c e s .
constants . speedFactor

61
62
63

def reset ( s e l f ) :
self .
init ( self . initiallocation )

64
65
66
67
68
69

c l a s s P l a y e r ( Movable ) :
def
i n i t ( self , location ) :
super () .
i n i t ( location )
s e l f . setimage ( ’ player ’ , resources . constants . playerSize )

70
71

72
73
74
75
76
77
78
79
80
81

82

d e f move ( s e l f , d i r e c t i o n , p a r t=r e s o u r c e s . c o n s t a n t s .
p l a y e r T i m e S e g m e n t S i z e − 1 , p a r t s i z e=r e s o u r c e s . c o n s t a n t s .
ghostTimeSegmentSize ) :
rotation = 0
i f s e l f . s p e e d == ( 1 , 0 ) :
rotation = 0
e l i f s e l f . s p e e d == ( −1 , 0 ) :
r o t a t i o n = 180
e l i f s e l f . s p e e d == ( 0 , −1) :
r o t a t i o n = 90
e l i f s e l f . s p e e d == ( 0 , 1 ) :
r o t a t i o n = 270
super () . setimage ( ’ player ’ , r e s o u r c e s . constants . playerSize ,
rotation )
s u p e r ( ) . move ( d i r e c t i o n , s e g m e n t s i z e=r e s o u r c e s . c o n s t a n t s .
playerTimeSegmentSize , p a r t=p a r t )

83
84
85
86
87
88
89
90
91

c l a s s Ghost ( Movable ) :
def
i n i t ( self , location , color ) :
super () .
i n i t ( location )
s e l f . color = color
s e l f . n e x t t i l e = None
s e l f . s e t i m a g e ( c o l o r+ ’ g h o s t ’ )
s e l f . previouslocation = s e l f . location

92
93

d e f move ( s e l f , d i r e c t i o n , p a r t=r e s o u r c e s . c o n s t a n t s .
ghostTimeSegmentSize − 1 , p a r t s i z e=r e s o u r c e s . c o n s t a n t s .

79

ghostTimeSegmentSize ) :
s e l f . previouslocation = s e l f . location
s u p e r ( ) . move ( d i r e c t i o n , p a r t s i z e , p a r t )

94
95
96
97
98

def reset ( s e l f ) :
self .
i n i t ( s e l f . initiallocation , s e l f . color )

99

4.3
1
2

levelprocessor.py

from PIL import Image
import r e s o u r c e s

3
4
5
6

7

8
9
10
11
12
13
14
15
16
17
18
19
20

21

22

23
24

25

def readlevel ( f i l e ) :
# l e v e l −l o a d i n g p r o c e d u r e with i n p u t o f g a m e s i z e ˆ2 bitmap
level file
l e v e l = [ [ r e s o u r c e s . constants . l e v e l d e f [ ’ nothing ’ ] f o r i in
range ( r e s o u r c e s . constants . gamesize ) ] f o r j in range ( r e s o u r c e s
. constants . gamesize ) ]
im = Image . open ( r e s o u r c e s . p a t h s . l e v e l s + f i l e )
im . l o a d ( )
f o r c o l in range (0 , r e s o u r c e s . constants . gamesize ) :
f o r row i n r a n g e ( 0 , r e s o u r c e s . c o n s t a n t s . g a m e s i z e ) :
p i x e l = im . g e t p i x e l ( ( c o l , row ) )
i f p i x e l == r e s o u r c e s . c o n s t a n t s . e d i t o r d e f [ ” c o i n ” ] :
l e v e l [ c o l ] [ row ] = r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’ c o i n ’ ]
e l i f p i x e l == r e s o u r c e s . c o n s t a n t s . e d i t o r d e f [ ” w a l l ” ] :
l e v e l [ c o l ] [ row ] = r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’ w a l l ’ ]
e l i f p i x e l == r e s o u r c e s . c o n s t a n t s . e d i t o r d e f [ ” p l a y e r ” ] :
l e v e l [ c o l ] [ row ] = r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’ p l a y e r ’ ]
e l i f p i x e l == r e s o u r c e s . c o n s t a n t s . e d i t o r d e f [ ” r e d g h o s t ” ] :
l e v e l [ c o l ] [ row ] = r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’
red ghost ’ ]
e l i f p i x e l == r e s o u r c e s . c o n s t a n t s . e d i t o r d e f [ ” g r e e n g h o s t ”
]:
l e v e l [ c o l ] [ row ] = r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’
green ghost ’ ]
e l i f p i x e l == r e s o u r c e s . c o n s t a n t s . e d i t o r d e f [ ” b l u e g h o s t ” ] :
l e v e l [ c o l ] [ row ] = r e s o u r c e s . c o n s t a n t s . l e v e l d e f [ ’
blue ghost ’ ]
return l e v e l

26

4.4
1
2
3

paths.py

r e s o u r c e s = ” . / r e s o u r c e s /”
g r a p h i c s = r e s o u r c e s + ” g r a p h i c s /”
l e v e l s = r e s o u r c e s + ” l e v e l s /”

4
5
6
7

image = {
” c o i n ” : g r a p h i c s + ” c o i n . png” ,
”w0001” : g r a p h i c s + ”w0001 . g i f ” ,

80

”w0010” : g r a p h i c s + ”w0010 . g i f ” ,
”w0011” : g r a p h i c s + ”w0011 . g i f ” ,
”w0100” : g r a p h i c s + ”w0100 . g i f ” ,
”w0101” : g r a p h i c s + ”w0101 . g i f ” ,
”w0110” : g r a p h i c s + ”w0110 . g i f ” ,
”w0111” : g r a p h i c s + ”w0111 . g i f ” ,
”w1000” : g r a p h i c s + ”w1000 . g i f ” ,
”w1001” : g r a p h i c s + ”w1001 . g i f ” ,
”w1010” : g r a p h i c s + ”w1010 . g i f ” ,
”w1011” : g r a p h i c s + ”w1011 . g i f ” ,
”w1100” : g r a p h i c s + ”w1100 . g i f ” ,
”w1101” : g r a p h i c s + ”w1101 . g i f ” ,
”w1110” : g r a p h i c s + ”w1110 . g i f ” ,
”w1111” : g r a p h i c s + ”w1111 . g i f ” ,
” p l a y e r ” : g r a p h i c s + ” p l a y e r . png” ,
” r e d g h o s t ” : g r a p h i c s + ” r e d g h o s t . png” ,
” b l u e g h o s t ” : g r a p h i c s + ” b l u e g h o s t . png” ,
” g r e e n g h o s t ” : g r a p h i c s + ” g r e e n g h o s t . png”

8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

}

27
28
29
30
31
32
33
34
35
36

levelorder = [
” l e v e l 0 . bmp” ,
” l e v e l 1 . bmp” ,
” l e v e l 2 . bmp” ,
” l e v e l 3 . bmp” ,
” l e v e l 4 . bmp” ,
” l e v e l 5 . bmp” ,
” l e v e l 6 . bmp”
]

37

81

Chapter 5

Levels appendix

82

Chapter 6

References
1. http://gameinternals.com/post/2072558330/understanding-pac-man-ghostbehavior
2. https://www.pygame.org/docs

83

